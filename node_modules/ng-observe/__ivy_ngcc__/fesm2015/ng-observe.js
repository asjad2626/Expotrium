import { InjectionToken, NgZone, Injectable, ChangeDetectorRef, Inject, Optional } from '@angular/core';
import { Subscription, isObservable } from 'rxjs';

import * as ɵngcc0 from '@angular/core';
const HASH_FN = new InjectionToken('HASH_FN', {
    providedIn: 'root',
    factory: createHashFn,
});
const BRAND = '__ngObserve__';
// @dynamic
class ObserveService {
    constructor(cdRef, hash, zone) {
        this.cdRef = cdRef;
        this.hash = hash;
        this.hooks = new Map();
        this.detectChanges = () => this.cdRef.detectChanges();
        this.collection = (sources, options = {}) => {
            const sink = Array.isArray(sources) ? [] : {};
            Object.defineProperty(sink, BRAND, {
                value: true,
                enumerable: false,
                writable: false,
            });
            const observe = this.observe(sink);
            Object.keys(sources).forEach(key => {
                const source = sources[key];
                const option = options[key];
                observe(key, source, option);
            });
            return sink;
        };
        this.value = (source, options) => {
            const sink = {};
            this.observe(sink)('value', source, options);
            return toValue(sink, 'value');
        };
        if (zone instanceof NgZone) {
            this.detectChanges = () => this.cdRef.markForCheck();
        }
    }
    createUniqueId(key) {
        try {
            throw new Error();
        }
        catch (e) {
            return String(this.hash(e.stack + String(key)));
        }
    }
    observe(sink) {
        const fn = (key, source, { uniqueId = this.createUniqueId(key), errorHandler = () => { } } = {}) => {
            let subscription = new Subscription();
            const noop = () => { };
            const unsubscribe = () => subscription.unsubscribe();
            const complete = () => {
                (this.hooks.get(uniqueId) || noop)();
                this.hooks.delete(uniqueId);
            };
            complete();
            this.hooks.set(uniqueId, unsubscribe);
            // tslint:disable-next-line: deprecation
            subscription = source.subscribe({
                next: x => {
                    sink[key] = x;
                    this.detectChanges();
                },
                error: errorHandler,
                complete,
            });
        };
        return fn;
    }
    ngOnDestroy() {
        this.hooks.forEach(unsubscribe => unsubscribe());
    }
}
ObserveService.ɵfac = function ObserveService_Factory(t) { return new (t || ObserveService)(ɵngcc0.ɵɵinject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵinject(HASH_FN), ɵngcc0.ɵɵinject(ɵngcc0.NgZone, 8)); };
ObserveService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ObserveService, factory: ObserveService.ɵfac });
ObserveService.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Inject, args: [HASH_FN,] }] },
    { type: NgZone, decorators: [{ type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ObserveService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [HASH_FN]
            }] }, { type: ɵngcc0.NgZone, decorators: [{
                type: Optional
            }] }]; }, null); })();
const OBSERVE = new InjectionToken('OBSERVE');
const OBSERVE_PROVIDER = [
    ObserveService,
    {
        provide: OBSERVE,
        useFactory: observeFactory,
        deps: [ObserveService],
    },
];
function observeFactory(service) {
    return (source, options) => isObservable(source)
        ? service.value(source, options)
        : service.collection(source, options);
}
class Observed {
    constructor(seed, mapFn) {
        this.seed = seed;
        this.getter = () => mapFn(this.seed);
    }
    get value() {
        return this.getter();
    }
}
function createHashFn() {
    const k = 2654435761;
    const shift = Math.imul ? (n) => Math.imul(n, k) : (n) => imul(n, k);
    const hashFn = (input) => {
        let index = input.length;
        let hash = 0xabadcafe;
        while (index--) {
            hash = shift(hash ^ input.charCodeAt(index));
        }
        return (hash ^ (hash >>> 16)) >>> 0;
    };
    return hashFn;
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
function imul(a, b) {
    b |= 0;
    let result = (a & 0x003fffff) * b;
    if (a & 0xffc00000) {
        result += ((a & 0xffc00000) * b) | 0;
    }
    return result | 0;
}
function isCollection(source) {
    return Boolean(source && source[BRAND]);
}
function toMappedValue(collection, mapFn) {
    return new Observed(collection, mapFn);
}
function toValue(collection, key) {
    return new Observed(collection, source => source[key]);
}
function toValues(collection) {
    if (Array.isArray(collection)) {
        return collection.map((_, index) => new Observed(collection, source => source[index]));
    }
    const values = {};
    for (const key in collection) {
        if (collection.hasOwnProperty(key)) {
            values[key] = new Observed(collection, source => source[key]);
        }
    }
    return values;
}

/**
 * Generated bundle index. Do not edit.
 */

export { HASH_FN, OBSERVE, OBSERVE_PROVIDER, ObserveService, Observed, createHashFn, imul, isCollection, observeFactory, toMappedValue, toValue, toValues };

//# sourceMappingURL=ng-observe.js.map