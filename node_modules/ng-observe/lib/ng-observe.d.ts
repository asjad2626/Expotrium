import { ChangeDetectorRef, InjectionToken, NgZone, OnDestroy } from '@angular/core';
import { Observable } from 'rxjs';
import * as ɵngcc0 from '@angular/core';
export declare const HASH_FN: InjectionToken<HashFn>;
export declare class ObserveService implements OnDestroy {
    private cdRef;
    private hash;
    private hooks;
    private detectChanges;
    collection: ObserveCollectionFn;
    value: ObserveValueFn;
    constructor(cdRef: ChangeDetectorRef, hash: HashFn, zone: NgZone);
    private createUniqueId;
    private observe;
    ngOnDestroy(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<ObserveService, [null, null, { optional: true; }]>;
    static ɵprov: ɵngcc0.ɵɵInjectableDeclaration<ObserveService>;
}
export declare const OBSERVE: InjectionToken<ObserveFn>;
export declare const OBSERVE_PROVIDER: (typeof ObserveService | {
    provide: InjectionToken<ObserveFn>;
    useFactory: typeof observeFactory;
    deps: (typeof ObserveService)[];
})[];
export declare function observeFactory(service: ObserveService): ObserveFn;
declare type ObserveCollectionFn = <Collection>(source: ObservableCollection<Collection>, options?: ObserveCollectionOptions<Collection>) => Collection;
declare type ObserveValueFn = <Value>(source: Observable<Value>, options?: ObserveValueOptions) => Observed<Value>;
export declare type ObserveFn = <Source extends Observable<any> | ObservableCollection<any>>(source: Source, options?: ObserveFnOptions<Source>) => ObserveFnReturnValue<Source>;
export declare type ObservableCollection<Collection> = Collection extends Array<infer Value> ? Array<Observable<Value>> : {
    [Key in keyof Collection]: Observable<Collection[Key]>;
};
export declare type ObserveCollectionOptions<Collection> = Collection extends Array<any> ? Array<ObserveValueOptions> : {
    [Key in keyof Collection]?: ObserveValueOptions;
};
export declare type ObservedValues<Collection> = Collection extends Array<infer Value> ? Array<Observed<Value>> : {
    [Key in keyof Collection]: Observed<Collection[Key]>;
};
export interface ObserveValueOptions {
    errorHandler?: (err: any) => void;
    uniqueId?: string;
}
export declare type ObserveFnOptions<Source> = Source extends Observable<any> ? ObserveValueOptions : Source extends ObservableCollection<infer Collection> ? ObserveCollectionOptions<Collection> : never;
export declare type ObserveFnReturnValue<Source> = Source extends Observable<infer Value> ? Observed<Value> : Source extends ObservableCollection<infer Collection> ? Collection : never;
export declare class Observed<Value, Seed = unknown> {
    private readonly seed;
    private readonly getter;
    constructor(seed: Seed, mapFn: (source: typeof seed) => Value);
    get value(): Value;
}
export declare type HashFn = (input: string) => number;
export declare function createHashFn(): HashFn;
export declare function imul(a: number, b: number): number;
export declare function isCollection(source: any): boolean;
export declare function toMappedValue<Value, Seed extends Array<any> | Record<string, any>>(collection: Seed, mapFn: (source: typeof collection) => Value): Observed<Value>;
export declare function toValue<Value>(collection: Array<Value>, key: number): Observed<Value>;
export declare function toValue<Value>(collection: Record<string, Value>, key: string): Observed<Value>;
export declare function toValues<Collection extends any[]>(collection: Collection): ObservedValues<Collection>;
export declare function toValues<Collection extends Record<string, any>>(collection: Collection): ObservedValues<Collection>;
export {};

//# sourceMappingURL=ng-observe.d.ts.map