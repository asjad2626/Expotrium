{"version":3,"file":"ng-observe.d.ts","sources":["ng-observe.d.ts"],"names":[],"mappings":"AAAA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { ChangeDetectorRef, InjectionToken, NgZone, OnDestroy } from '@angular/core';\nimport { Observable } from 'rxjs';\nexport declare const HASH_FN: InjectionToken<HashFn>;\nexport declare class ObserveService implements OnDestroy {\n    private cdRef;\n    private hash;\n    private hooks;\n    private detectChanges;\n    collection: ObserveCollectionFn;\n    value: ObserveValueFn;\n    constructor(cdRef: ChangeDetectorRef, hash: HashFn, zone: NgZone);\n    private createUniqueId;\n    private observe;\n    ngOnDestroy(): void;\n}\nexport declare const OBSERVE: InjectionToken<ObserveFn>;\nexport declare const OBSERVE_PROVIDER: (typeof ObserveService | {\n    provide: InjectionToken<ObserveFn>;\n    useFactory: typeof observeFactory;\n    deps: (typeof ObserveService)[];\n})[];\nexport declare function observeFactory(service: ObserveService): ObserveFn;\ndeclare type ObserveCollectionFn = <Collection>(source: ObservableCollection<Collection>, options?: ObserveCollectionOptions<Collection>) => Collection;\ndeclare type ObserveValueFn = <Value>(source: Observable<Value>, options?: ObserveValueOptions) => Observed<Value>;\nexport declare type ObserveFn = <Source extends Observable<any> | ObservableCollection<any>>(source: Source, options?: ObserveFnOptions<Source>) => ObserveFnReturnValue<Source>;\nexport declare type ObservableCollection<Collection> = Collection extends Array<infer Value> ? Array<Observable<Value>> : {\n    [Key in keyof Collection]: Observable<Collection[Key]>;\n};\nexport declare type ObserveCollectionOptions<Collection> = Collection extends Array<any> ? Array<ObserveValueOptions> : {\n    [Key in keyof Collection]?: ObserveValueOptions;\n};\nexport declare type ObservedValues<Collection> = Collection extends Array<infer Value> ? Array<Observed<Value>> : {\n    [Key in keyof Collection]: Observed<Collection[Key]>;\n};\nexport interface ObserveValueOptions {\n    errorHandler?: (err: any) => void;\n    uniqueId?: string;\n}\nexport declare type ObserveFnOptions<Source> = Source extends Observable<any> ? ObserveValueOptions : Source extends ObservableCollection<infer Collection> ? ObserveCollectionOptions<Collection> : never;\nexport declare type ObserveFnReturnValue<Source> = Source extends Observable<infer Value> ? Observed<Value> : Source extends ObservableCollection<infer Collection> ? Collection : never;\nexport declare class Observed<Value, Seed = unknown> {\n    private readonly seed;\n    private readonly getter;\n    constructor(seed: Seed, mapFn: (source: typeof seed) => Value);\n    get value(): Value;\n}\nexport declare type HashFn = (input: string) => number;\nexport declare function createHashFn(): HashFn;\nexport declare function imul(a: number, b: number): number;\nexport declare function isCollection(source: any): boolean;\nexport declare function toMappedValue<Value, Seed extends Array<any> | Record<string, any>>(collection: Seed, mapFn: (source: typeof collection) => Value): Observed<Value>;\nexport declare function toValue<Value>(collection: Array<Value>, key: number): Observed<Value>;\nexport declare function toValue<Value>(collection: Record<string, Value>, key: string): Observed<Value>;\nexport declare function toValues<Collection extends any[]>(collection: Collection): ObservedValues<Collection>;\nexport declare function toValues<Collection extends Record<string, any>>(collection: Collection): ObservedValues<Collection>;\nexport {};\n"]}