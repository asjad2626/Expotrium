{"version":3,"sources":["../../../projects/ng-observe/src/lib/ng-observe.ts"],"names":["HASH_FN","InjectionToken","providedIn","factory","createHashFn","BRAND","ObserveService","cdRef","hash","zone","_this","this","hooks","Map","detectChanges","collection","sources","options","sink","Array","isArray","Object","defineProperty","value","enumerable","writable","observe","keys","forEach","key","source","option","toValue","NgZone","markForCheck","prototype","createUniqueId","Error","e","String","stack","_a","_b","_c","uniqueId","_d","errorHandler","subscription","Subscription","noop","complete","get","delete","set","unsubscribe","subscribe","next","x","error","ngOnDestroy","Injectable","ChangeDetectorRef","Inject","args","decorators","type","Optional","OBSERVE","OBSERVE_PROVIDER","provide","useFactory","observeFactory","deps","service","isObservable","Observed","seed","mapFn","getter","k","shift","Math","imul","n","input","index","length","charCodeAt","a","b","result","Boolean","map","_","values","hasOwnProperty"],"mappings":"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","sourcesContent":["import {\n  ChangeDetectorRef,\n  Inject,\n  Injectable,\n  InjectionToken,\n  NgZone,\n  OnDestroy,\n  Optional,\n} from '@angular/core';\nimport { isObservable, Observable, Subscription } from 'rxjs';\n\nexport const HASH_FN = new InjectionToken<HashFn>('HASH_FN', {\n  providedIn: 'root',\n  factory: createHashFn,\n});\n\nconst BRAND = '__ngObserve__';\n\n// @dynamic\n@Injectable()\nexport class ObserveService implements OnDestroy {\n  private hooks = new Map<string | number, () => void>();\n  private detectChanges = () => this.cdRef.detectChanges();\n\n  collection: ObserveCollectionFn = (sources, options = {} as any) => {\n    const sink: any = Array.isArray(sources) ? [] : {};\n    Object.defineProperty(sink, BRAND, {\n      value: true,\n      enumerable: false,\n      writable: false,\n    });\n\n    const observe = this.observe(sink);\n    Object.keys(sources).forEach(key => {\n      const source: any = sources[key as keyof typeof sources];\n      const option: any = options[key as keyof typeof options];\n      observe(key, source, option);\n    });\n\n    return sink;\n  };\n\n  value: ObserveValueFn = <Value>(\n    source: Observable<Value>,\n    options?: ObserveValueOptions\n  ): Observed<Value> => {\n    const sink = {};\n\n    this.observe(sink)('value', source, options);\n\n    return toValue(sink, 'value');\n  };\n\n  constructor(\n    private cdRef: ChangeDetectorRef,\n    @Inject(HASH_FN) private hash: HashFn,\n    @Optional() zone: NgZone\n  ) {\n    if (zone instanceof NgZone) {\n      this.detectChanges = () => this.cdRef.markForCheck();\n    }\n  }\n\n  private createUniqueId(key: string | number | symbol): string {\n    try {\n      throw new Error();\n    } catch (e) {\n      return String(this.hash(e.stack + String(key)));\n    }\n  }\n\n  private observe(sink: any): Observe {\n    const fn = <Value>(\n      key: string | number | symbol,\n      source: Observable<Value>,\n      { uniqueId = this.createUniqueId(key), errorHandler = () => {} }: ObserveValueOptions = {}\n    ) => {\n      let subscription = new Subscription();\n      const noop = () => {};\n      const unsubscribe = () => subscription.unsubscribe();\n      const complete = () => {\n        (this.hooks.get(uniqueId) || noop)();\n        this.hooks.delete(uniqueId);\n      };\n\n      complete();\n      this.hooks.set(uniqueId, unsubscribe);\n\n      // tslint:disable-next-line: deprecation\n      subscription = source.subscribe({\n        next: x => {\n          sink[key] = x;\n          this.detectChanges();\n        },\n        error: errorHandler,\n        complete,\n      });\n    };\n\n    return fn;\n  }\n\n  ngOnDestroy(): void {\n    this.hooks.forEach(unsubscribe => unsubscribe());\n  }\n}\n\nexport const OBSERVE = new InjectionToken<ObserveFn>('OBSERVE');\n\nexport const OBSERVE_PROVIDER = [\n  ObserveService,\n  {\n    provide: OBSERVE,\n    useFactory: observeFactory,\n    deps: [ObserveService],\n  },\n];\n\nexport function observeFactory(service: ObserveService): ObserveFn {\n  return <ValueOrCollection extends any>(\n    source: Observable<ValueOrCollection> | ObservableCollection<ValueOrCollection>,\n    options?: ObserveValueOptions | ObserveCollectionOptions<ValueOrCollection>\n  ) =>\n    isObservable(source)\n      ? service.value(source, options as ObserveValueOptions)\n      : service.collection(source, options as ObserveCollectionOptions<ValueOrCollection>);\n}\n\ntype ObserveCollectionFn = <Collection>(\n  source: ObservableCollection<Collection>,\n  options?: ObserveCollectionOptions<Collection>\n) => Collection;\n\ntype ObserveValueFn = <Value>(\n  source: Observable<Value>,\n  options?: ObserveValueOptions\n) => Observed<Value>;\n\nexport type ObserveFn = <Source extends Observable<any> | ObservableCollection<any>>(\n  source: Source,\n  options?: ObserveFnOptions<Source>\n) => ObserveFnReturnValue<Source>;\n\ntype Observe = <Value>(\n  key: string | number | symbol,\n  source: Observable<Value>,\n  options?: ObserveValueOptions\n) => void;\n\nexport type ObservableCollection<Collection> = Collection extends Array<infer Value>\n  ? Array<Observable<Value>>\n  : { [Key in keyof Collection]: Observable<Collection[Key]> };\n\nexport type ObserveCollectionOptions<Collection> = Collection extends Array<any>\n  ? Array<ObserveValueOptions>\n  : { [Key in keyof Collection]?: ObserveValueOptions };\n\nexport type ObservedValues<Collection> = Collection extends Array<infer Value>\n  ? Array<Observed<Value>>\n  : { [Key in keyof Collection]: Observed<Collection[Key]> };\n\nexport interface ObserveValueOptions {\n  errorHandler?: (err: any) => void;\n  uniqueId?: string;\n}\n\nexport type ObserveFnOptions<Source> = Source extends Observable<any>\n  ? ObserveValueOptions\n  : Source extends ObservableCollection<infer Collection>\n  ? ObserveCollectionOptions<Collection>\n  : never;\n\nexport type ObserveFnReturnValue<Source> = Source extends Observable<infer Value>\n  ? Observed<Value>\n  : Source extends ObservableCollection<infer Collection>\n  ? Collection\n  : never;\n\nexport class Observed<Value, Seed = unknown> {\n  private readonly getter: () => Value;\n\n  constructor(private readonly seed: Seed, mapFn: (source: typeof seed) => Value) {\n    this.getter = () => mapFn(this.seed);\n  }\n\n  get value(): Value {\n    return this.getter();\n  }\n}\n\nexport type HashFn = (input: string) => number;\n\nexport function createHashFn(): HashFn {\n  const k = 2654435761;\n  const shift = Math.imul ? (n: number) => Math.imul(n, k) : (n: number) => imul(n, k);\n\n  const hashFn = (input: string) => {\n    let index = input.length;\n    let hash = 0xabadcafe;\n\n    while (index--) {\n      hash = shift(hash ^ input.charCodeAt(index));\n    }\n\n    return (hash ^ (hash >>> 16)) >>> 0;\n  };\n\n  return hashFn;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\nexport function imul(a: number, b: number): number {\n  b |= 0;\n\n  let result = (a & 0x003fffff) * b;\n  if (a & 0xffc00000) {\n    result += ((a & 0xffc00000) * b) | 0;\n  }\n\n  return result | 0;\n}\n\nexport function isCollection(source: any): boolean {\n  return Boolean(source && source[BRAND]);\n}\n\nexport function toMappedValue<Value, Seed extends Array<any> | Record<string, any>>(\n  collection: Seed,\n  mapFn: (source: typeof collection) => Value\n): Observed<Value> {\n  return new Observed(collection as any, mapFn);\n}\n\nexport function toValue<Value>(collection: Array<Value>, key: number): Observed<Value>;\nexport function toValue<Value>(collection: Record<string, Value>, key: string): Observed<Value>;\nexport function toValue<Value>(\n  collection: Array<Value> | Record<string, Value>,\n  key: number | string\n): Observed<Value> {\n  return new Observed(collection as any, source => source[key]);\n}\n\nexport function toValues<Collection extends any[]>(\n  collection: Collection\n): ObservedValues<Collection>;\nexport function toValues<Collection extends Record<string, any>>(\n  collection: Collection\n): ObservedValues<Collection>;\nexport function toValues<Value>(\n  collection: Value[] | Record<string, Value>\n): ObservedValues<Value[] | Record<string, Value>> {\n  if (Array.isArray(collection)) {\n    return collection.map((_, index) => new Observed(collection, source => source[index]));\n  }\n\n  const values: Record<string, Observed<Value>> = {};\n\n  for (const key in collection) {\n    if (collection.hasOwnProperty(key)) {\n      values[key] = new Observed(collection, source => source[key]);\n    }\n  }\n\n  return values;\n}\n"]}