(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs')) :
    typeof define === 'function' && define.amd ? define('ng-observe', ['exports', '@angular/core', 'rxjs'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ng-observe'] = {}, global.ng.core, global.rxjs));
}(this, (function (exports, core, rxjs) { 'use strict';

    var HASH_FN = new core.InjectionToken('HASH_FN', {
        providedIn: 'root',
        factory: createHashFn,
    });
    var BRAND = '__ngObserve__';
    // @dynamic
    var ObserveService = /** @class */ (function () {
        function ObserveService(cdRef, hash, zone) {
            var _this = this;
            this.cdRef = cdRef;
            this.hash = hash;
            this.hooks = new Map();
            this.detectChanges = function () { return _this.cdRef.detectChanges(); };
            this.collection = function (sources, options) {
                if (options === void 0) { options = {}; }
                var sink = Array.isArray(sources) ? [] : {};
                Object.defineProperty(sink, BRAND, {
                    value: true,
                    enumerable: false,
                    writable: false,
                });
                var observe = _this.observe(sink);
                Object.keys(sources).forEach(function (key) {
                    var source = sources[key];
                    var option = options[key];
                    observe(key, source, option);
                });
                return sink;
            };
            this.value = function (source, options) {
                var sink = {};
                _this.observe(sink)('value', source, options);
                return toValue(sink, 'value');
            };
            if (zone instanceof core.NgZone) {
                this.detectChanges = function () { return _this.cdRef.markForCheck(); };
            }
        }
        ObserveService.prototype.createUniqueId = function (key) {
            try {
                throw new Error();
            }
            catch (e) {
                return String(this.hash(e.stack + String(key)));
            }
        };
        ObserveService.prototype.observe = function (sink) {
            var _this = this;
            var fn = function (key, source, _a) {
                var _b = _a === void 0 ? {} : _a, _c = _b.uniqueId, uniqueId = _c === void 0 ? _this.createUniqueId(key) : _c, _d = _b.errorHandler, errorHandler = _d === void 0 ? function () { } : _d;
                var subscription = new rxjs.Subscription();
                var noop = function () { };
                var unsubscribe = function () { return subscription.unsubscribe(); };
                var complete = function () {
                    (_this.hooks.get(uniqueId) || noop)();
                    _this.hooks.delete(uniqueId);
                };
                complete();
                _this.hooks.set(uniqueId, unsubscribe);
                // tslint:disable-next-line: deprecation
                subscription = source.subscribe({
                    next: function (x) {
                        sink[key] = x;
                        _this.detectChanges();
                    },
                    error: errorHandler,
                    complete: complete,
                });
            };
            return fn;
        };
        ObserveService.prototype.ngOnDestroy = function () {
            this.hooks.forEach(function (unsubscribe) { return unsubscribe(); });
        };
        return ObserveService;
    }());
    ObserveService.decorators = [
        { type: core.Injectable }
    ];
    ObserveService.ctorParameters = function () { return [
        { type: core.ChangeDetectorRef },
        { type: undefined, decorators: [{ type: core.Inject, args: [HASH_FN,] }] },
        { type: core.NgZone, decorators: [{ type: core.Optional }] }
    ]; };
    var OBSERVE = new core.InjectionToken('OBSERVE');
    var OBSERVE_PROVIDER = [
        ObserveService,
        {
            provide: OBSERVE,
            useFactory: observeFactory,
            deps: [ObserveService],
        },
    ];
    function observeFactory(service) {
        return function (source, options) { return rxjs.isObservable(source)
            ? service.value(source, options)
            : service.collection(source, options); };
    }
    var Observed = /** @class */ (function () {
        function Observed(seed, mapFn) {
            var _this = this;
            this.seed = seed;
            this.getter = function () { return mapFn(_this.seed); };
        }
        Object.defineProperty(Observed.prototype, "value", {
            get: function () {
                return this.getter();
            },
            enumerable: false,
            configurable: true
        });
        return Observed;
    }());
    function createHashFn() {
        var k = 2654435761;
        var shift = Math.imul ? function (n) { return Math.imul(n, k); } : function (n) { return imul(n, k); };
        var hashFn = function (input) {
            var index = input.length;
            var hash = 0xabadcafe;
            while (index--) {
                hash = shift(hash ^ input.charCodeAt(index));
            }
            return (hash ^ (hash >>> 16)) >>> 0;
        };
        return hashFn;
    }
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
    function imul(a, b) {
        b |= 0;
        var result = (a & 0x003fffff) * b;
        if (a & 0xffc00000) {
            result += ((a & 0xffc00000) * b) | 0;
        }
        return result | 0;
    }
    function isCollection(source) {
        return Boolean(source && source[BRAND]);
    }
    function toMappedValue(collection, mapFn) {
        return new Observed(collection, mapFn);
    }
    function toValue(collection, key) {
        return new Observed(collection, function (source) { return source[key]; });
    }
    function toValues(collection) {
        if (Array.isArray(collection)) {
            return collection.map(function (_, index) { return new Observed(collection, function (source) { return source[index]; }); });
        }
        var values = {};
        var _loop_1 = function (key) {
            if (collection.hasOwnProperty(key)) {
                values[key] = new Observed(collection, function (source) { return source[key]; });
            }
        };
        for (var key in collection) {
            _loop_1(key);
        }
        return values;
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.HASH_FN = HASH_FN;
    exports.OBSERVE = OBSERVE;
    exports.OBSERVE_PROVIDER = OBSERVE_PROVIDER;
    exports.ObserveService = ObserveService;
    exports.Observed = Observed;
    exports.createHashFn = createHashFn;
    exports.imul = imul;
    exports.isCollection = isCollection;
    exports.observeFactory = observeFactory;
    exports.toMappedValue = toMappedValue;
    exports.toValue = toValue;
    exports.toValues = toValues;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ng-observe.umd.js.map
