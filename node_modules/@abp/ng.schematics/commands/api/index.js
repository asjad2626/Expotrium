"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const enums_1 = require("../../enums");
const utils_1 = require("../../utils");
const cases = require("../../utils/text");
function default_1(schema) {
    const params = (0, utils_1.removeDefaultPlaceholders)(schema);
    const moduleName = params.module || 'app';
    return (0, schematics_1.chain)([
        async (tree) => {
            const getRootNamespace = (0, utils_1.createRootNamespaceGetter)(params);
            const solution = await getRootNamespace(tree);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const target = await (0, utils_1.resolveProject)(tree, params.target);
            const targetPath = (0, utils_1.buildTargetPath)(target.definition, params.entryPoint);
            const readProxyConfig = (0, utils_1.createProxyConfigReader)(targetPath);
            const createProxyConfigWriter = (0, utils_1.createProxyConfigWriterCreator)(targetPath);
            const data = readProxyConfig(tree);
            const types = data.types;
            const modules = data.modules;
            const serviceType = schema.serviceType || enums_1.defaultEServiceType;
            if (!types || !modules)
                throw new schematics_1.SchematicsException("[Invalid API Definition] The provided API definition is invalid." /* Exception.InvalidApiDefinition */);
            const definition = data.modules[moduleName];
            if (!definition)
                throw new schematics_1.SchematicsException((0, utils_1.interpolate)("[Invalid Module] Backend module \"{0}\" does not exist in API definition." /* Exception.InvalidModule */, moduleName));
            const apiName = definition.remoteServiceName;
            const controllers = filterControllersByServiceType(serviceType, definition.controllers);
            const serviceImports = {};
            const generateServices = createServiceGenerator({
                targetPath,
                solution,
                types,
                apiName,
                controllers,
                serviceImports,
            });
            const modelImports = {};
            const generateModels = createModelGenerator({
                targetPath,
                solution,
                types,
                serviceImports,
                modelImports,
            });
            const generateEnums = createEnumGenerator({
                targetPath,
                solution,
                types,
                serviceImports,
                modelImports,
            });
            if (!data.generated.includes(moduleName))
                data.generated.push(moduleName);
            data.generated.sort();
            const json = (0, utils_1.generateProxyConfigJson)(data);
            const overwriteProxyConfig = createProxyConfigWriter('overwrite', json);
            return (0, schematics_1.branchAndMerge)((0, schematics_1.chain)([generateServices, generateModels, generateEnums, overwriteProxyConfig]));
        },
    ]);
}
exports.default = default_1;
function createEnumGenerator(params) {
    const { targetPath, serviceImports, modelImports } = params;
    const mapImportRefToEnum = (0, utils_1.createImportRefToEnumMapper)(params);
    const enumRefs = [
        ...new Set([
            ...(0, utils_1.getEnumNamesFromImports)(serviceImports),
            ...(0, utils_1.getEnumNamesFromImports)(modelImports),
        ]),
    ];
    return (0, schematics_1.chain)(enumRefs.map(ref => {
        return (0, utils_1.applyWithOverwrite)((0, schematics_1.url)('./files-enum'), [
            (0, schematics_1.applyTemplates)({
                ...cases,
                ...mapImportRefToEnum(ref),
            }),
            (0, schematics_1.move)((0, core_1.normalize)(targetPath)),
        ]);
    }));
}
function createModelGenerator(params) {
    const { targetPath, serviceImports, modelImports } = params;
    const reduceImportRefsToModels = (0, utils_1.createImportRefsToModelReducer)(params);
    const models = Object.values(serviceImports).reduce(reduceImportRefsToModels, []);
    models.forEach(({ imports }) => imports.forEach(({ refs, path }) => refs.forEach(ref => {
        if (path === '@abp/ng.core')
            return;
        if (!modelImports[path])
            return (modelImports[path] = [ref]);
        modelImports[path] = [...new Set([...modelImports[path], ref])];
    })));
    return (0, schematics_1.chain)(models.map(model => (0, utils_1.applyWithOverwrite)((0, schematics_1.url)('./files-model'), [
        (0, schematics_1.applyTemplates)({
            ...cases,
            ...model,
        }),
        (0, schematics_1.move)((0, core_1.normalize)(targetPath)),
    ])));
}
function createServiceGenerator(params) {
    const { targetPath, controllers, serviceImports } = params;
    const mapControllerToService = (0, utils_1.createControllerToServiceMapper)(params);
    return (0, schematics_1.chain)(controllers.map(controller => {
        const service = mapControllerToService(controller);
        service.imports.forEach(({ refs, path }) => refs.forEach(ref => {
            if (path === '@abp/ng.core')
                return;
            if (!serviceImports[path])
                return (serviceImports[path] = [ref]);
            serviceImports[path] = [...new Set([...serviceImports[path], ref])];
        }));
        return (0, utils_1.applyWithOverwrite)((0, schematics_1.url)('./files-service'), [
            (0, schematics_1.applyTemplates)({
                ...cases,
                serializeParameters: utils_1.serializeParameters,
                ...service,
            }),
            (0, schematics_1.move)((0, core_1.normalize)(targetPath)),
        ]);
    }));
}
function filterControllersByServiceType(serviceType, controllers) {
    const itShouldBeIntegratedService = serviceType === enums_1.eServiceType.Integration;
    const skipFilter = serviceType === enums_1.eServiceType.All;
    return Object.values(controllers || {}).filter(x => x.isIntegrationService === itShouldBeIntegratedService || skipFilter);
}
//# sourceMappingURL=index.js.map