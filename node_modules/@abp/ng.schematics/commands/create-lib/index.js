"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLibSecondaryEntry = exports.updateTsConfig = exports.addLibToWorkspaceIfNotExist = void 0;
const schematics_1 = require("@angular-devkit/schematics");
const utils_1 = require("../../utils");
const cases = require("../../utils/text");
const core_1 = require("@angular-devkit/core");
const generate_lib_1 = require("../../utils/angular-schematic/generate-lib");
function default_1(schema) {
    return async (tree) => {
        if (schema.override || !(await checkLibExist(schema, tree))) {
            return (0, schematics_1.chain)([createLibrary(schema)]);
        }
    };
}
exports.default = default_1;
async function checkLibExist(options, tree) {
    const packageName = (0, utils_1.kebab)(options.packageName);
    if (options.isSecondaryEntrypoint) {
        const lib = await (0, utils_1.resolveProject)(tree, options.target);
        const ngPackagePath = `${lib?.definition.root}/${packageName}/ng-package.json`;
        const packageInfo = tree.read(ngPackagePath);
        if (packageInfo) {
            throw new schematics_1.SchematicsException((0, utils_1.interpolate)("[Library Already Exists] \"{0}\" already exists. Use --override to override." /* Exception.LibraryAlreadyExists */, `${lib.name}/${packageName}`));
        }
        return false;
    }
    const target = await (0, utils_1.resolveProject)(tree, options.packageName, null);
    if (target) {
        throw new schematics_1.SchematicsException((0, utils_1.interpolate)("[Library Already Exists] \"{0}\" already exists. Use --override to override." /* Exception.LibraryAlreadyExists */, packageName));
    }
    return false;
}
function createLibrary(options) {
    return async (tree) => {
        const target = await (0, utils_1.resolveProject)(tree, options.packageName, null);
        if (!target || options.override) {
            if (options.isModuleTemplate) {
                return createLibFromModuleTemplate(tree, options);
            }
            if (options.isSecondaryEntrypoint) {
                return createLibSecondaryEntry(tree, options);
            }
        }
        else {
            throw new schematics_1.SchematicsException((0, utils_1.interpolate)("[Library Already Exists] \"{0}\" already exists. Use --override to override." /* Exception.LibraryAlreadyExists */, options.packageName));
        }
    };
}
async function resolvePackagesDirFromAngularJson(host) {
    const workspace = await (0, utils_1.getWorkspace)(host);
    const projectFolder = readFirstLibInAngularJson(workspace);
    return projectFolder?.root?.split('/')?.[0] || 'projects';
}
function readFirstLibInAngularJson(workspace) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    return Array.from(workspace.projects.values()).find(value => (0, utils_1.isLibrary)(value));
}
async function createLibFromModuleTemplate(tree, options) {
    const packagesDir = await resolvePackagesDirFromAngularJson(tree);
    const packageJson = JSON.parse(tree.read('./package.json').toString());
    const abpVersion = packageJson.dependencies['@abp/ng.core'];
    return (0, schematics_1.chain)([
        (0, utils_1.applyWithOverwrite)((0, schematics_1.url)('./files-package'), [
            (0, schematics_1.applyTemplates)({
                ...cases,
                libraryName: options.packageName,
                abpVersion,
            }),
            (0, schematics_1.move)((0, core_1.normalize)(packagesDir)),
        ]),
        addLibToWorkspaceIfNotExist(options.packageName, packagesDir),
    ]);
}
function addLibToWorkspaceIfNotExist(name, packagesDir) {
    return async (tree) => {
        const workspace = await (0, utils_1.getWorkspace)(tree);
        const packageName = (0, utils_1.kebab)(name);
        const isProjectExist = workspace.projects.has(packageName);
        const projectRoot = (0, core_1.join)((0, core_1.normalize)(packagesDir), packageName);
        const pathImportLib = `${packagesDir}/${packageName}`;
        return (0, schematics_1.chain)([
            isProjectExist
                ? (0, utils_1.updateWorkspace)(w => {
                    w.projects.delete(packageName);
                })
                : (0, schematics_1.noop)(),
            (0, generate_lib_1.addLibToWorkspaceFile)(projectRoot, packageName),
            updateTsConfig(packageName, pathImportLib),
        ]);
    };
}
exports.addLibToWorkspaceIfNotExist = addLibToWorkspaceIfNotExist;
function updateTsConfig(packageName, path) {
    return (host) => {
        const files = ['tsconfig.json', 'tsconfig.app.json', 'tsconfig.base.json'];
        const tsConfig = files.find(f => host.exists(f));
        if (!tsConfig) {
            return host;
        }
        const file = new utils_1.JSONFile(host, tsConfig);
        const jsonPath = ['compilerOptions', 'paths', packageName];
        file.modify(jsonPath, [`${path}/src/public-api.ts`]);
    };
}
exports.updateTsConfig = updateTsConfig;
async function createLibSecondaryEntry(tree, options) {
    const targetLib = await (0, utils_1.resolveProject)(tree, options.target);
    const packageName = `${(0, utils_1.kebab)(targetLib.name)}/${(0, utils_1.kebab)(options.packageName)}`;
    const importPath = `${targetLib.definition.root}/${(0, utils_1.kebab)(options.packageName)}`;
    return (0, schematics_1.chain)([
        (0, utils_1.applyWithOverwrite)((0, schematics_1.url)('./files-secondary-entrypoint'), [
            (0, schematics_1.applyTemplates)({
                ...cases,
                libraryName: options.packageName,
                target: targetLib.name,
            }),
            (0, schematics_1.move)((0, core_1.normalize)(targetLib.definition.root)),
            updateTsConfig(packageName, importPath),
        ]),
    ]);
}
exports.createLibSecondaryEntry = createLibSecondaryEntry;
//# sourceMappingURL=index.js.map