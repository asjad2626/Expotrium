"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createActionToSignatureMapper = exports.createActionToBodyMapper = exports.createActionToMethodMapper = exports.createControllerToServiceMapper = exports.serializeParameters = void 0;
const models_1 = require("../models");
const import_1 = require("./import");
const namespace_1 = require("./namespace");
const tree_1 = require("./tree");
const type_1 = require("./type");
const enums_1 = require("../enums");
const text_1 = require("./text");
const constants_1 = require("../constants");
function serializeParameters(parameters) {
    return parameters.map(p => p.name + p.optional + ': ' + p.type + p.default, '').join(', ');
}
exports.serializeParameters = serializeParameters;
function createControllerToServiceMapper({ solution, types, apiName, }) {
    const mapActionToMethod = createActionToMethodMapper();
    return (controller) => {
        const name = controller.controllerName;
        const namespace = (0, namespace_1.parseNamespace)(solution, controller.type);
        const actions = Object.values(controller.actions);
        const typeWithoutIRemoteStreamContent = getTypesWithoutIRemoteStreamContent(types);
        const imports = actions.reduce(createActionToImportsReducer(solution, typeWithoutIRemoteStreamContent, namespace), []);
        imports.push(new models_1.Import({ path: '@abp/ng.core', specifiers: ['RestService'] }));
        imports.push(new models_1.Import({ path: '@angular/core', specifiers: ['Injectable'] }));
        (0, import_1.sortImports)(imports);
        const methods = actions.map(mapActionToMethod);
        sortMethods(methods);
        return new models_1.Service({ apiName, imports, methods, name, namespace });
    };
}
exports.createControllerToServiceMapper = createControllerToServiceMapper;
function getTypesWithoutIRemoteStreamContent(types) {
    const newType = { ...types };
    delete newType[constants_1.VOLO_REMOTE_STREAM_CONTENT];
    return newType;
}
function sortMethods(methods) {
    methods.sort((a, b) => (a.signature.name > b.signature.name ? 1 : -1));
}
function createActionToMethodMapper() {
    const mapActionToBody = createActionToBodyMapper();
    const mapActionToSignature = createActionToSignatureMapper();
    return (action) => {
        const body = mapActionToBody(action);
        const signature = mapActionToSignature(action);
        return new models_1.Method({ body, signature });
    };
}
exports.createActionToMethodMapper = createActionToMethodMapper;
function createActionToBodyMapper() {
    const adaptType = (0, type_1.createTypeAdapter)();
    return ({ httpMethod, parameters, returnValue, url }) => {
        const responseType = adaptType(returnValue.typeSimple);
        const responseTypeWithNamespace = returnValue.typeSimple;
        const body = new models_1.Body({ method: httpMethod, responseType, url, responseTypeWithNamespace });
        parameters.forEach(body.registerActionParameter);
        return body;
    };
}
exports.createActionToBodyMapper = createActionToBodyMapper;
function createActionToSignatureMapper() {
    const adaptType = (0, type_1.createTypeAdapter)();
    return (action) => {
        const signature = new models_1.Signature({ name: getMethodNameFromAction(action) });
        const versionParameter = getVersionParameter(action);
        const parameters = [
            ...action.parametersOnMethod,
            ...(versionParameter ? [versionParameter] : []),
        ];
        signature.parameters = parameters.map(p => {
            const type = adaptType(p.typeSimple);
            const parameter = new models_1.Property({ name: p.name, type });
            parameter.setDefault(p.defaultValue);
            parameter.setOptional(p.isOptional);
            return parameter;
        });
        return signature;
    };
}
exports.createActionToSignatureMapper = createActionToSignatureMapper;
function getMethodNameFromAction(action) {
    return action.uniqueName.split('Async')[0];
}
function getVersionParameter(action) {
    const versionParameter = action.parameters.find(p => (p.name == 'apiVersion' && p.bindingSourceId == enums_1.eBindingSourceId.Path) ||
        (p.name == 'api-version' && p.bindingSourceId == enums_1.eBindingSourceId.Query));
    const bestVersion = findBestApiVersion(action);
    return versionParameter && bestVersion
        ? {
            ...versionParameter,
            name: (0, text_1.camelizeHyphen)(versionParameter.name),
            defaultValue: `"${bestVersion}"`,
        }
        : null;
}
// Implementation of https://github.com/abpframework/abp/commit/c3f77c1229508279015054a9b4f5586404a88a14#diff-a4dbf6be9a1aa21d8294f11047774949363ee6b601980bf3225e8046c0748c9eR101
function findBestApiVersion(action) {
    /*
    TODO: Implement  configuredVersion when js proxies implemented
    let configuredVersion = null;
     if (action.supportedVersions.includes(configuredVersion)) {
      return configuredVersion;
    }
    */
    if (!action.supportedVersions?.length) {
        // TODO: return configuredVersion if exists or '1.0'
        return '1.0';
    }
    //TODO: Ensure to get the latest version!
    return action.supportedVersions[action.supportedVersions.length - 1];
}
function createActionToImportsReducer(solution, types, namespace) {
    const mapTypesToImports = (0, type_1.createTypesToImportsReducer)(solution, namespace);
    const parseType = (0, type_1.createTypeParser)(type_1.removeTypeModifiers);
    return (imports, { parametersOnMethod, returnValue }) => mapTypesToImports(imports, [returnValue, ...parametersOnMethod].reduce((acc, param) => {
        parseType(param.type).forEach(paramType => (0, tree_1.parseGenerics)(paramType)
            .toGenerics()
            .forEach(type => {
            if (types[type])
                acc.push({ type, isEnum: types[type].isEnum });
        }));
        return acc;
    }, []));
}
//# sourceMappingURL=service.js.map