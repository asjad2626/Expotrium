import { ConfigStateService, getShortDateFormat, getShortDateShortTimeFormat, getShortTimeFormat, ListService, PermissionService, } from '@abp/ng.core';
import { formatDate } from '@angular/common';
import { ChangeDetectionStrategy, Component, EventEmitter, Inject, Injector, Input, LOCALE_ID, Output, TemplateRef, } from '@angular/core';
import { map } from 'rxjs/operators';
import { ExtensionsService } from '../../services/extensions.service';
import { ENTITY_PROP_TYPE_CLASSES, EXTENSIONS_IDENTIFIER, PROP_DATA_STREAM, } from '../../tokens/extensions.token';
import * as i0 from "@angular/core";
import * as i1 from "@abp/ng.core";
import * as i2 from "@angular/common";
import * as i3 from "@swimlane/ngx-datatable";
import * as i4 from "@abp/ng.theme.shared";
import * as i5 from "../grid-actions/grid-actions.component";
const DEFAULT_ACTIONS_COLUMN_WIDTH = 150;
export class ExtensibleTableComponent {
    constructor(locale, config, injector) {
        this.locale = locale;
        this.config = config;
        this.injector = injector;
        this.tableActivate = new EventEmitter();
        this.trackByFn = (_, item) => item.name;
        this.entityPropTypeClasses = injector.get(ENTITY_PROP_TYPE_CLASSES);
        this.getInjected = injector.get.bind(injector);
        const extensions = injector.get(ExtensionsService);
        const name = injector.get(EXTENSIONS_IDENTIFIER);
        this.propList = extensions.entityProps.get(name).props;
        this.actionList = extensions['entityActions'].get(name)
            .actions;
        const permissionService = injector.get(PermissionService);
        this.hasAtLeastOnePermittedAction =
            permissionService.filterItemsByPolicy(this.actionList.toArray().map(action => ({ requiredPolicy: action.permission }))).length > 0;
        this.setColumnWidths(DEFAULT_ACTIONS_COLUMN_WIDTH);
    }
    set actionsText(value) {
        this._actionsText = value;
    }
    get actionsText() {
        return this._actionsText ?? (this.actionList.length > 1 ? 'AbpUi::Actions' : '');
    }
    set actionsColumnWidth(width) {
        this.setColumnWidths(width ? Number(width) : undefined);
    }
    setColumnWidths(actionsColumn) {
        const widths = [actionsColumn];
        this.propList.forEach(({ value: prop }) => {
            widths.push(prop.columnWidth);
        });
        this.columnWidths = widths;
    }
    getDate(value, format) {
        return value ? formatDate(value, format, this.locale) : '';
    }
    getIcon(value) {
        return value
            ? '<div class="text-success"><i class="fa fa-check"></i></div>'
            : '<div class="text-danger"><i class="fa fa-times"></i></div>';
    }
    getEnum(rowValue, list) {
        if (!list)
            return rowValue;
        const { key } = list.find(({ value }) => value === rowValue);
        return key;
    }
    getContent(prop, data) {
        return prop.valueResolver(data).pipe(map(value => {
            switch (prop.type) {
                case "boolean" /* ePropType.Boolean */:
                    return this.getIcon(value);
                case "date" /* ePropType.Date */:
                    return this.getDate(value, getShortDateFormat(this.config));
                case "time" /* ePropType.Time */:
                    return this.getDate(value, getShortTimeFormat(this.config));
                case "datetime" /* ePropType.DateTime */:
                    return this.getDate(value, getShortDateShortTimeFormat(this.config));
                case "enum" /* ePropType.Enum */:
                    return this.getEnum(value, prop.enumList);
                default:
                    return value;
                // More types can be handled in the future
            }
        }));
    }
    ngOnChanges({ data }) {
        if (!data?.currentValue)
            return;
        this.data = data.currentValue.map((record, index) => {
            this.propList.forEach(prop => {
                const propData = { getInjected: this.getInjected, record, index };
                const value = this.getContent(prop.value, propData);
                const propKey = `_${prop.value.name}`;
                record[propKey] = {
                    visible: prop.value.visible(propData),
                    value,
                };
                if (prop.value.component) {
                    const injector = Injector.create({
                        providers: [
                            {
                                provide: PROP_DATA_STREAM,
                                useValue: value,
                            },
                        ],
                        parent: this.injector,
                    });
                    record[propKey].injector = injector;
                    record[propKey].component = prop.value.component;
                }
            });
            return record;
        });
    }
}
ExtensibleTableComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.3", ngImport: i0, type: ExtensibleTableComponent, deps: [{ token: LOCALE_ID }, { token: i1.ConfigStateService }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
ExtensibleTableComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.3", type: ExtensibleTableComponent, selector: "abp-extensible-table", inputs: { actionsText: "actionsText", data: "data", list: "list", recordsTotal: "recordsTotal", actionsColumnWidth: "actionsColumnWidth", actionsTemplate: "actionsTemplate" }, outputs: { tableActivate: "tableActivate" }, exportAs: ["abpExtensibleTable"], usesOnChanges: true, ngImport: i0, template: "<ngx-datatable\r\n  default\r\n  [rows]=\"data\"\r\n  [count]=\"recordsTotal\"\r\n  [list]=\"list\"\r\n  (activate)=\"tableActivate.emit($event)\"\r\n>\r\n  <ngx-datatable-column\r\n    *ngIf=\"actionsTemplate || (actionList.length && hasAtLeastOnePermittedAction)\"\r\n    [name]=\"actionsText | abpLocalization\"\r\n    [maxWidth]=\"columnWidths[0]\"\r\n    [width]=\"columnWidths[0]\"\r\n    [sortable]=\"false\"\r\n  >\r\n    <ng-template let-row=\"row\" let-i=\"rowIndex\" ngx-datatable-cell-template>\r\n      <ng-container\r\n        *ngTemplateOutlet=\"actionsTemplate || gridActions; context: { $implicit: row, index: i }\"\r\n      ></ng-container>\r\n      <ng-template #gridActions>\r\n        <abp-grid-actions [index]=\"i\" [record]=\"row\" text=\"AbpUi::Actions\"></abp-grid-actions>\r\n      </ng-template>\r\n    </ng-template>\r\n  </ngx-datatable-column>\r\n\r\n  <ng-container *ngFor=\"let prop of propList; let i = index; trackBy: trackByFn\">\r\n    <ngx-datatable-column\r\n      [width]=\"columnWidths[i + 1] || 200\"\r\n      [name]=\"prop.displayName | abpLocalization\"\r\n      [prop]=\"prop.name\"\r\n      [sortable]=\"prop.sortable\"\r\n    >\r\n      <ng-template let-row=\"row\" let-i=\"index\" ngx-datatable-cell-template>\r\n        <ng-container *abpPermission=\"prop.permission; runChangeDetection: false\">\r\n          <ng-container *ngIf=\"row['_' + prop.name]?.visible\">\r\n            <div\r\n              *ngIf=\"!row['_' + prop.name].component; else component\"\r\n              [innerHTML]=\"row['_' + prop.name]?.value | async\"\r\n              (click)=\"\r\n                prop.action && prop.action({ getInjected: getInjected, record: row, index: i })\r\n              \"\r\n              [ngClass]=\"entityPropTypeClasses[prop.type]\"\r\n              [class.pointer]=\"prop.action\"\r\n            ></div>\r\n          </ng-container>\r\n          <ng-template #component>\r\n            <ng-container\r\n              *ngComponentOutlet=\"\r\n                row['_' + prop.name].component;\r\n                injector: row['_' + prop.name].injector\r\n              \"\r\n            ></ng-container>\r\n          </ng-template>\r\n        </ng-container>\r\n      </ng-template>\r\n    </ngx-datatable-column>\r\n  </ng-container>\r\n</ngx-datatable>\r\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModule", "ngComponentOutletNgModuleFactory"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i1.PermissionDirective, selector: "[abpPermission]", inputs: ["abpPermission", "abpPermissionRunChangeDetection"] }, { kind: "component", type: i3.DatatableComponent, selector: "ngx-datatable", inputs: ["targetMarkerTemplate", "rows", "groupRowsBy", "groupedRows", "columns", "selected", "scrollbarV", "scrollbarH", "rowHeight", "columnMode", "headerHeight", "footerHeight", "externalPaging", "externalSorting", "limit", "count", "offset", "loadingIndicator", "selectionType", "reorderable", "swapColumns", "sortType", "sorts", "cssClasses", "messages", "rowClass", "selectCheck", "displayCheck", "groupExpansionDefault", "trackByProp", "selectAllRowsOnPage", "virtualization", "treeFromRelation", "treeToRelation", "summaryRow", "summaryHeight", "summaryPosition", "rowIdentity"], outputs: ["scroll", "activate", "select", "sort", "page", "reorder", "resize", "tableContextmenu", "treeAction"] }, { kind: "directive", type: i3.DataTableColumnDirective, selector: "ngx-datatable-column", inputs: ["name", "prop", "frozenLeft", "frozenRight", "flexGrow", "resizeable", "comparator", "pipe", "sortable", "draggable", "canAutoResize", "minWidth", "width", "maxWidth", "checkboxable", "headerCheckboxable", "headerClass", "cellClass", "isTreeColumn", "treeLevelIndent", "summaryFunc", "summaryTemplate", "cellTemplate", "headerTemplate", "treeToggleTemplate"] }, { kind: "directive", type: i3.DataTableColumnCellDirective, selector: "[ngx-datatable-cell-template]" }, { kind: "directive", type: i4.NgxDatatableDefaultDirective, selector: "ngx-datatable[default]", inputs: ["class"], exportAs: ["ngxDatatableDefault"] }, { kind: "directive", type: i4.NgxDatatableListDirective, selector: "ngx-datatable[list]", inputs: ["list"], exportAs: ["ngxDatatableList"] }, { kind: "component", type: i5.GridActionsComponent, selector: "abp-grid-actions", inputs: ["icon", "index", "text"], exportAs: ["abpGridActions"] }, { kind: "pipe", type: i2.AsyncPipe, name: "async" }, { kind: "pipe", type: i1.LocalizationPipe, name: "abpLocalization" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.3", ngImport: i0, type: ExtensibleTableComponent, decorators: [{
            type: Component,
            args: [{ exportAs: 'abpExtensibleTable', selector: 'abp-extensible-table', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ngx-datatable\r\n  default\r\n  [rows]=\"data\"\r\n  [count]=\"recordsTotal\"\r\n  [list]=\"list\"\r\n  (activate)=\"tableActivate.emit($event)\"\r\n>\r\n  <ngx-datatable-column\r\n    *ngIf=\"actionsTemplate || (actionList.length && hasAtLeastOnePermittedAction)\"\r\n    [name]=\"actionsText | abpLocalization\"\r\n    [maxWidth]=\"columnWidths[0]\"\r\n    [width]=\"columnWidths[0]\"\r\n    [sortable]=\"false\"\r\n  >\r\n    <ng-template let-row=\"row\" let-i=\"rowIndex\" ngx-datatable-cell-template>\r\n      <ng-container\r\n        *ngTemplateOutlet=\"actionsTemplate || gridActions; context: { $implicit: row, index: i }\"\r\n      ></ng-container>\r\n      <ng-template #gridActions>\r\n        <abp-grid-actions [index]=\"i\" [record]=\"row\" text=\"AbpUi::Actions\"></abp-grid-actions>\r\n      </ng-template>\r\n    </ng-template>\r\n  </ngx-datatable-column>\r\n\r\n  <ng-container *ngFor=\"let prop of propList; let i = index; trackBy: trackByFn\">\r\n    <ngx-datatable-column\r\n      [width]=\"columnWidths[i + 1] || 200\"\r\n      [name]=\"prop.displayName | abpLocalization\"\r\n      [prop]=\"prop.name\"\r\n      [sortable]=\"prop.sortable\"\r\n    >\r\n      <ng-template let-row=\"row\" let-i=\"index\" ngx-datatable-cell-template>\r\n        <ng-container *abpPermission=\"prop.permission; runChangeDetection: false\">\r\n          <ng-container *ngIf=\"row['_' + prop.name]?.visible\">\r\n            <div\r\n              *ngIf=\"!row['_' + prop.name].component; else component\"\r\n              [innerHTML]=\"row['_' + prop.name]?.value | async\"\r\n              (click)=\"\r\n                prop.action && prop.action({ getInjected: getInjected, record: row, index: i })\r\n              \"\r\n              [ngClass]=\"entityPropTypeClasses[prop.type]\"\r\n              [class.pointer]=\"prop.action\"\r\n            ></div>\r\n          </ng-container>\r\n          <ng-template #component>\r\n            <ng-container\r\n              *ngComponentOutlet=\"\r\n                row['_' + prop.name].component;\r\n                injector: row['_' + prop.name].injector\r\n              \"\r\n            ></ng-container>\r\n          </ng-template>\r\n        </ng-container>\r\n      </ng-template>\r\n    </ngx-datatable-column>\r\n  </ng-container>\r\n</ngx-datatable>\r\n" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }, { type: i1.ConfigStateService }, { type: i0.Injector }]; }, propDecorators: { actionsText: [{
                type: Input
            }], data: [{
                type: Input
            }], list: [{
                type: Input
            }], recordsTotal: [{
                type: Input
            }], actionsColumnWidth: [{
                type: Input
            }], actionsTemplate: [{
                type: Input
            }], tableActivate: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0ZW5zaWJsZS10YWJsZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy90aGVtZS1zaGFyZWQvZXh0ZW5zaW9ucy9zcmMvbGliL2NvbXBvbmVudHMvZXh0ZW5zaWJsZS10YWJsZS9leHRlbnNpYmxlLXRhYmxlLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL3RoZW1lLXNoYXJlZC9leHRlbnNpb25zL3NyYy9saWIvY29tcG9uZW50cy9leHRlbnNpYmxlLXRhYmxlL2V4dGVuc2libGUtdGFibGUuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVMLGtCQUFrQixFQUNsQixrQkFBa0IsRUFDbEIsMkJBQTJCLEVBQzNCLGtCQUFrQixFQUNsQixXQUFXLEVBQ1gsaUJBQWlCLEdBQ2xCLE1BQU0sY0FBYyxDQUFDO0FBQ3RCLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUM3QyxPQUFPLEVBQ0wsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxZQUFZLEVBQ1osTUFBTSxFQUdOLFFBQVEsRUFDUixLQUFLLEVBQ0wsU0FBUyxFQUVULE1BQU0sRUFFTixXQUFXLEdBR1osTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBS3JDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBQ3RFLE9BQU8sRUFDTCx3QkFBd0IsRUFFeEIscUJBQXFCLEVBQ3JCLGdCQUFnQixHQUNqQixNQUFNLCtCQUErQixDQUFDOzs7Ozs7O0FBRXZDLE1BQU0sNEJBQTRCLEdBQUcsR0FBRyxDQUFDO0FBUXpDLE1BQU0sT0FBTyx3QkFBd0I7SUFrQ25DLFlBQzZCLE1BQWMsRUFDakMsTUFBMEIsRUFDMUIsUUFBa0I7UUFGQyxXQUFN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QixnVkNqRHJDLHl3RUF5REE7MkZEUmEsd0JBQXdCO2tCQU5wQyxTQUFTOytCQUNFLG9CQUFvQixZQUNwQixzQkFBc0IsbUJBRWYsdUJBQXVCLENBQUMsTUFBTTs7MEJBcUM1QyxNQUFNOzJCQUFDLFNBQVM7b0dBaENmLFdBQVc7c0JBRGQsS0FBSztnQkFRRyxJQUFJO3NCQUFaLEtBQUs7Z0JBQ0csSUFBSTtzQkFBWixLQUFLO2dCQUNHLFlBQVk7c0JBQXBCLEtBQUs7Z0JBQ08sa0JBQWtCO3NCQUE5QixLQUFLO2dCQUdHLGVBQWU7c0JBQXZCLEtBQUs7Z0JBRUksYUFBYTtzQkFBdEIsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgQUJQLFxyXG4gIENvbmZpZ1N0YXRlU2VydmljZSxcclxuICBnZXRTaG9ydERhdGVGb3JtYXQsXHJcbiAgZ2V0U2hvcnREYXRlU2hvcnRUaW1lRm9ybWF0LFxyXG4gIGdldFNob3J0VGltZUZvcm1hdCxcclxuICBMaXN0U2VydmljZSxcclxuICBQZXJtaXNzaW9uU2VydmljZSxcclxufSBmcm9tICdAYWJwL25nLmNvcmUnO1xyXG5pbXBvcnQgeyBmb3JtYXREYXRlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHtcclxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcclxuICBDb21wb25lbnQsXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIEluamVjdCxcclxuICBJbmplY3RGbGFncyxcclxuICBJbmplY3Rpb25Ub2tlbixcclxuICBJbmplY3RvcixcclxuICBJbnB1dCxcclxuICBMT0NBTEVfSUQsXHJcbiAgT25DaGFuZ2VzLFxyXG4gIE91dHB1dCxcclxuICBTaW1wbGVDaGFuZ2VzLFxyXG4gIFRlbXBsYXRlUmVmLFxyXG4gIFRyYWNrQnlGdW5jdGlvbixcclxuICBUeXBlLFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgZVByb3BUeXBlIH0gZnJvbSAnLi4vLi4vZW51bXMvcHJvcHMuZW51bSc7XHJcbmltcG9ydCB7IEVudGl0eUFjdGlvbkxpc3QgfSBmcm9tICcuLi8uLi9tb2RlbHMvZW50aXR5LWFjdGlvbnMnO1xyXG5pbXBvcnQgeyBFbnRpdHlQcm9wLCBFbnRpdHlQcm9wTGlzdCB9IGZyb20gJy4uLy4uL21vZGVscy9lbnRpdHktcHJvcHMnO1xyXG5pbXBvcnQgeyBQcm9wRGF0YSB9IGZyb20gJy4uLy4uL21vZGVscy9wcm9wcyc7XHJcbmltcG9ydCB7IEV4dGVuc2lvbnNTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvZXh0ZW5zaW9ucy5zZXJ2aWNlJztcclxuaW1wb3J0IHtcclxuICBFTlRJVFlfUFJPUF9UWVBFX0NMQVNTRVMsXHJcbiAgRW50aXR5UHJvcFR5cGVDbGFzcyxcclxuICBFWFRFTlNJT05TX0lERU5USUZJRVIsXHJcbiAgUFJPUF9EQVRBX1NUUkVBTSxcclxufSBmcm9tICcuLi8uLi90b2tlbnMvZXh0ZW5zaW9ucy50b2tlbic7XHJcblxyXG5jb25zdCBERUZBVUxUX0FDVElPTlNfQ09MVU1OX1dJRFRIID0gMTUwO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgZXhwb3J0QXM6ICdhYnBFeHRlbnNpYmxlVGFibGUnLFxyXG4gIHNlbGVjdG9yOiAnYWJwLWV4dGVuc2libGUtdGFibGUnLFxyXG4gIHRlbXBsYXRlVXJsOiAnLi9leHRlbnNpYmxlLXRhYmxlLmNvbXBvbmVudC5odG1sJyxcclxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxufSlcclxuZXhwb3J0IGNsYXNzIEV4dGVuc2libGVUYWJsZUNvbXBvbmVudDxSID0gYW55PiBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XHJcbiAgcHJvdGVjdGVkIF9hY3Rpb25zVGV4dDogc3RyaW5nO1xyXG4gIEBJbnB1dCgpXHJcbiAgc2V0IGFjdGlvbnNUZXh0KHZhbHVlOiBzdHJpbmcpIHtcclxuICAgIHRoaXMuX2FjdGlvbnNUZXh0ID0gdmFsdWU7XHJcbiAgfVxyXG4gIGdldCBhY3Rpb25zVGV4dCgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuX2FjdGlvbnNUZXh0ID8/ICh0aGlzLmFjdGlvbkxpc3QubGVuZ3RoID4gMSA/ICdBYnBVaTo6QWN0aW9ucycgOiAnJyk7XHJcbiAgfVxyXG5cclxuICBASW5wdXQoKSBkYXRhOiBSW107XHJcbiAgQElucHV0KCkgbGlzdDogTGlzdFNlcnZpY2U7XHJcbiAgQElucHV0KCkgcmVjb3Jkc1RvdGFsOiBudW1iZXI7XHJcbiAgQElucHV0KCkgc2V0IGFjdGlvbnNDb2x1bW5XaWR0aCh3aWR0aDogbnVtYmVyKSB7XHJcbiAgICB0aGlzLnNldENvbHVtbldpZHRocyh3aWR0aCA/IE51bWJlcih3aWR0aCkgOiB1bmRlZmluZWQpO1xyXG4gIH1cclxuICBASW5wdXQoKSBhY3Rpb25zVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcblxyXG4gIEBPdXRwdXQoKSB0YWJsZUFjdGl2YXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG5cclxuICBnZXRJbmplY3RlZDogPFQ+KHRva2VuOiBUeXBlPFQ+IHwgSW5qZWN0aW9uVG9rZW48VD4sIG5vdEZvdW5kVmFsdWU/OiBULCBmbGFncz86IEluamVjdEZsYWdzKSA9PiBUO1xyXG5cclxuICBoYXNBdExlYXN0T25lUGVybWl0dGVkQWN0aW9uOiBib29sZWFuO1xyXG5cclxuICBlbnRpdHlQcm9wVHlwZUNsYXNzZXM6IEVudGl0eVByb3BUeXBlQ2xhc3M7XHJcblxyXG4gIHJlYWRvbmx5IGNvbHVtbldpZHRoczogbnVtYmVyW107XHJcblxyXG4gIHJlYWRvbmx5IHByb3BMaXN0OiBFbnRpdHlQcm9wTGlzdDxSPjtcclxuXHJcbiAgcmVhZG9ubHkgYWN0aW9uTGlzdDogRW50aXR5QWN0aW9uTGlzdDxSPjtcclxuXHJcbiAgcmVhZG9ubHkgdHJhY2tCeUZuOiBUcmFja0J5RnVuY3Rpb248RW50aXR5UHJvcDxSPj4gPSAoXywgaXRlbSkgPT4gaXRlbS5uYW1lO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIEBJbmplY3QoTE9DQUxFX0lEKSBwcml2YXRlIGxvY2FsZTogc3RyaW5nLFxyXG4gICAgcHJpdmF0ZSBjb25maWc6IENvbmZpZ1N0YXRlU2VydmljZSxcclxuICAgIHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yLFxyXG4gICkge1xyXG4gICAgdGhpcy5lbnRpdHlQcm9wVHlwZUNsYXNzZXMgPSBpbmplY3Rvci5nZXQoRU5USVRZX1BST1BfVFlQRV9DTEFTU0VTKTtcclxuICAgIHRoaXMuZ2V0SW5qZWN0ZWQgPSBpbmplY3Rvci5nZXQuYmluZChpbmplY3Rvcik7XHJcbiAgICBjb25zdCBleHRlbnNpb25zID0gaW5qZWN0b3IuZ2V0KEV4dGVuc2lvbnNTZXJ2aWNlKTtcclxuICAgIGNvbnN0IG5hbWUgPSBpbmplY3Rvci5nZXQoRVhURU5TSU9OU19JREVOVElGSUVSKTtcclxuICAgIHRoaXMucHJvcExpc3QgPSBleHRlbnNpb25zLmVudGl0eVByb3BzLmdldChuYW1lKS5wcm9wcztcclxuICAgIHRoaXMuYWN0aW9uTGlzdCA9IGV4dGVuc2lvbnNbJ2VudGl0eUFjdGlvbnMnXS5nZXQobmFtZSlcclxuICAgICAgLmFjdGlvbnMgYXMgdW5rbm93biBhcyBFbnRpdHlBY3Rpb25MaXN0PFI+O1xyXG5cclxuICAgIGNvbnN0IHBlcm1pc3Npb25TZXJ2aWNlID0gaW5qZWN0b3IuZ2V0KFBlcm1pc3Npb25TZXJ2aWNlKTtcclxuICAgIHRoaXMuaGFzQXRMZWFzdE9uZVBlcm1pdHRlZEFjdGlvbiA9XHJcbiAgICAgIHBlcm1pc3Npb25TZXJ2aWNlLmZpbHRlckl0ZW1zQnlQb2xpY3koXHJcbiAgICAgICAgdGhpcy5hY3Rpb25MaXN0LnRvQXJyYXkoKS5tYXAoYWN0aW9uID0+ICh7IHJlcXVpcmVkUG9saWN5OiBhY3Rpb24ucGVybWlzc2lvbiB9KSksXHJcbiAgICAgICkubGVuZ3RoID4gMDtcclxuICAgIHRoaXMuc2V0Q29sdW1uV2lkdGhzKERFRkFVTFRfQUNUSU9OU19DT0xVTU5fV0lEVEgpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzZXRDb2x1bW5XaWR0aHMoYWN0aW9uc0NvbHVtbjogbnVtYmVyKSB7XHJcbiAgICBjb25zdCB3aWR0aHMgPSBbYWN0aW9uc0NvbHVtbl07XHJcbiAgICB0aGlzLnByb3BMaXN0LmZvckVhY2goKHsgdmFsdWU6IHByb3AgfSkgPT4ge1xyXG4gICAgICB3aWR0aHMucHVzaChwcm9wLmNvbHVtbldpZHRoKTtcclxuICAgIH0pO1xyXG4gICAgKHRoaXMuY29sdW1uV2lkdGhzIGFzIGFueSkgPSB3aWR0aHM7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldERhdGUodmFsdWU6IERhdGUsIGZvcm1hdDogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPyBmb3JtYXREYXRlKHZhbHVlLCBmb3JtYXQsIHRoaXMubG9jYWxlKSA6ICcnO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXRJY29uKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICByZXR1cm4gdmFsdWVcclxuICAgICAgPyAnPGRpdiBjbGFzcz1cInRleHQtc3VjY2Vzc1wiPjxpIGNsYXNzPVwiZmEgZmEtY2hlY2tcIj48L2k+PC9kaXY+J1xyXG4gICAgICA6ICc8ZGl2IGNsYXNzPVwidGV4dC1kYW5nZXJcIj48aSBjbGFzcz1cImZhIGZhLXRpbWVzXCI+PC9pPjwvZGl2Pic7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldEVudW0ocm93VmFsdWU6IGFueSwgbGlzdDogQXJyYXk8QUJQLk9wdGlvbjxhbnk+Pikge1xyXG4gICAgaWYgKCFsaXN0KSByZXR1cm4gcm93VmFsdWU7XHJcbiAgICBjb25zdCB7IGtleSB9ID0gbGlzdC5maW5kKCh7IHZhbHVlIH0pID0+IHZhbHVlID09PSByb3dWYWx1ZSk7XHJcbiAgICByZXR1cm4ga2V5O1xyXG4gIH1cclxuXHJcbiAgZ2V0Q29udGVudChwcm9wOiBFbnRpdHlQcm9wPFI+LCBkYXRhOiBQcm9wRGF0YSk6IE9ic2VydmFibGU8c3RyaW5nPiB7XHJcbiAgICByZXR1cm4gcHJvcC52YWx1ZVJlc29sdmVyKGRhdGEpLnBpcGUoXHJcbiAgICAgIG1hcCh2YWx1ZSA9PiB7XHJcbiAgICAgICAgc3dpdGNoIChwcm9wLnR5cGUpIHtcclxuICAgICAgICAgIGNhc2UgZVByb3BUeXBlLkJvb2xlYW46XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEljb24odmFsdWUpO1xyXG4gICAgICAgICAgY2FzZSBlUHJvcFR5cGUuRGF0ZTpcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0ZSh2YWx1ZSwgZ2V0U2hvcnREYXRlRm9ybWF0KHRoaXMuY29uZmlnKSk7XHJcbiAgICAgICAgICBjYXNlIGVQcm9wVHlwZS5UaW1lOlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRlKHZhbHVlLCBnZXRTaG9ydFRpbWVGb3JtYXQodGhpcy5jb25maWcpKTtcclxuICAgICAgICAgIGNhc2UgZVByb3BUeXBlLkRhdGVUaW1lOlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRlKHZhbHVlLCBnZXRTaG9ydERhdGVTaG9ydFRpbWVGb3JtYXQodGhpcy5jb25maWcpKTtcclxuICAgICAgICAgIGNhc2UgZVByb3BUeXBlLkVudW06XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEVudW0odmFsdWUsIHByb3AuZW51bUxpc3QpO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgLy8gTW9yZSB0eXBlcyBjYW4gYmUgaGFuZGxlZCBpbiB0aGUgZnV0dXJlXHJcbiAgICAgICAgfVxyXG4gICAgICB9KSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBuZ09uQ2hhbmdlcyh7IGRhdGEgfTogU2ltcGxlQ2hhbmdlcykge1xyXG4gICAgaWYgKCFkYXRhPy5jdXJyZW50VmFsdWUpIHJldHVybjtcclxuXHJcbiAgICB0aGlzLmRhdGEgPSBkYXRhLmN1cnJlbnRWYWx1ZS5tYXAoKHJlY29yZCwgaW5kZXgpID0+IHtcclxuICAgICAgdGhpcy5wcm9wTGlzdC5mb3JFYWNoKHByb3AgPT4ge1xyXG4gICAgICAgIGNvbnN0IHByb3BEYXRhID0geyBnZXRJbmplY3RlZDogdGhpcy5nZXRJbmplY3RlZCwgcmVjb3JkLCBpbmRleCB9IGFzIGFueTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0Q29udGVudChwcm9wLnZhbHVlLCBwcm9wRGF0YSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHByb3BLZXkgPSBgXyR7cHJvcC52YWx1ZS5uYW1lfWA7XHJcbiAgICAgICAgcmVjb3JkW3Byb3BLZXldID0ge1xyXG4gICAgICAgICAgdmlzaWJsZTogcHJvcC52YWx1ZS52aXNpYmxlKHByb3BEYXRhKSxcclxuICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHByb3AudmFsdWUuY29tcG9uZW50KSB7XHJcbiAgICAgICAgICBjb25zdCBpbmplY3RvciA9IEluamVjdG9yLmNyZWF0ZSh7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHByb3ZpZGU6IFBST1BfREFUQV9TVFJFQU0sXHJcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogdmFsdWUsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgcGFyZW50OiB0aGlzLmluamVjdG9yLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICByZWNvcmRbcHJvcEtleV0uaW5qZWN0b3IgPSBpbmplY3RvcjtcclxuICAgICAgICAgIHJlY29yZFtwcm9wS2V5XS5jb21wb25lbnQgPSBwcm9wLnZhbHVlLmNvbXBvbmVudDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHJlY29yZDtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG4iLCI8bmd4LWRhdGF0YWJsZVxyXG4gIGRlZmF1bHRcclxuICBbcm93c109XCJkYXRhXCJcclxuICBbY291bnRdPVwicmVjb3Jkc1RvdGFsXCJcclxuICBbbGlzdF09XCJsaXN0XCJcclxuICAoYWN0aXZhdGUpPVwidGFibGVBY3RpdmF0ZS5lbWl0KCRldmVudClcIlxyXG4+XHJcbiAgPG5neC1kYXRhdGFibGUtY29sdW1uXHJcbiAgICAqbmdJZj1cImFjdGlvbnNUZW1wbGF0ZSB8fCAoYWN0aW9uTGlzdC5sZW5ndGggJiYgaGFzQXRMZWFzdE9uZVBlcm1pdHRlZEFjdGlvbilcIlxyXG4gICAgW25hbWVdPVwiYWN0aW9uc1RleHQgfCBhYnBMb2NhbGl6YXRpb25cIlxyXG4gICAgW21heFdpZHRoXT1cImNvbHVtbldpZHRoc1swXVwiXHJcbiAgICBbd2lkdGhdPVwiY29sdW1uV2lkdGhzWzBdXCJcclxuICAgIFtzb3J0YWJsZV09XCJmYWxzZVwiXHJcbiAgPlxyXG4gICAgPG5nLXRlbXBsYXRlIGxldC1yb3c9XCJyb3dcIiBsZXQtaT1cInJvd0luZGV4XCIgbmd4LWRhdGF0YWJsZS1jZWxsLXRlbXBsYXRlPlxyXG4gICAgICA8bmctY29udGFpbmVyXHJcbiAgICAgICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJhY3Rpb25zVGVtcGxhdGUgfHwgZ3JpZEFjdGlvbnM7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiByb3csIGluZGV4OiBpIH1cIlxyXG4gICAgICA+PC9uZy1jb250YWluZXI+XHJcbiAgICAgIDxuZy10ZW1wbGF0ZSAjZ3JpZEFjdGlvbnM+XHJcbiAgICAgICAgPGFicC1ncmlkLWFjdGlvbnMgW2luZGV4XT1cImlcIiBbcmVjb3JkXT1cInJvd1wiIHRleHQ9XCJBYnBVaTo6QWN0aW9uc1wiPjwvYWJwLWdyaWQtYWN0aW9ucz5cclxuICAgICAgPC9uZy10ZW1wbGF0ZT5cclxuICAgIDwvbmctdGVtcGxhdGU+XHJcbiAgPC9uZ3gtZGF0YXRhYmxlLWNvbHVtbj5cclxuXHJcbiAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgcHJvcCBvZiBwcm9wTGlzdDsgbGV0IGkgPSBpbmRleDsgdHJhY2tCeTogdHJhY2tCeUZuXCI+XHJcbiAgICA8bmd4LWRhdGF0YWJsZS1jb2x1bW5cclxuICAgICAgW3dpZHRoXT1cImNvbHVtbldpZHRoc1tpICsgMV0gfHwgMjAwXCJcclxuICAgICAgW25hbWVdPVwicHJvcC5kaXNwbGF5TmFtZSB8IGFicExvY2FsaXphdGlvblwiXHJcbiAgICAgIFtwcm9wXT1cInByb3AubmFtZVwiXHJcbiAgICAgIFtzb3J0YWJsZV09XCJwcm9wLnNvcnRhYmxlXCJcclxuICAgID5cclxuICAgICAgPG5nLXRlbXBsYXRlIGxldC1yb3c9XCJyb3dcIiBsZXQtaT1cImluZGV4XCIgbmd4LWRhdGF0YWJsZS1jZWxsLXRlbXBsYXRlPlxyXG4gICAgICAgIDxuZy1jb250YWluZXIgKmFicFBlcm1pc3Npb249XCJwcm9wLnBlcm1pc3Npb247IHJ1bkNoYW5nZURldGVjdGlvbjogZmFsc2VcIj5cclxuICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJyb3dbJ18nICsgcHJvcC5uYW1lXT8udmlzaWJsZVwiPlxyXG4gICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgKm5nSWY9XCIhcm93WydfJyArIHByb3AubmFtZV0uY29tcG9uZW50OyBlbHNlIGNvbXBvbmVudFwiXHJcbiAgICAgICAgICAgICAgW2lubmVySFRNTF09XCJyb3dbJ18nICsgcHJvcC5uYW1lXT8udmFsdWUgfCBhc3luY1wiXHJcbiAgICAgICAgICAgICAgKGNsaWNrKT1cIlxyXG4gICAgICAgICAgICAgICAgcHJvcC5hY3Rpb24gJiYgcHJvcC5hY3Rpb24oeyBnZXRJbmplY3RlZDogZ2V0SW5qZWN0ZWQsIHJlY29yZDogcm93LCBpbmRleDogaSB9KVxyXG4gICAgICAgICAgICAgIFwiXHJcbiAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiZW50aXR5UHJvcFR5cGVDbGFzc2VzW3Byb3AudHlwZV1cIlxyXG4gICAgICAgICAgICAgIFtjbGFzcy5wb2ludGVyXT1cInByb3AuYWN0aW9uXCJcclxuICAgICAgICAgICAgPjwvZGl2PlxyXG4gICAgICAgICAgPC9uZy1jb250YWluZXI+XHJcbiAgICAgICAgICA8bmctdGVtcGxhdGUgI2NvbXBvbmVudD5cclxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICpuZ0NvbXBvbmVudE91dGxldD1cIlxyXG4gICAgICAgICAgICAgICAgcm93WydfJyArIHByb3AubmFtZV0uY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgaW5qZWN0b3I6IHJvd1snXycgKyBwcm9wLm5hbWVdLmluamVjdG9yXHJcbiAgICAgICAgICAgICAgXCJcclxuICAgICAgICAgICAgPjwvbmctY29udGFpbmVyPlxyXG4gICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cclxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cclxuICAgICAgPC9uZy10ZW1wbGF0ZT5cclxuICAgIDwvbmd4LWRhdGF0YWJsZS1jb2x1bW4+XHJcbiAgPC9uZy1jb250YWluZXI+XHJcbjwvbmd4LWRhdGF0YWJsZT5cclxuIl19