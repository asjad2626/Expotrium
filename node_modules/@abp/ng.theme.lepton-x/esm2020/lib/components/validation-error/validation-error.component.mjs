import { ChangeDetectionStrategy, Component, ViewEncapsulation } from '@angular/core';
import { ValidationErrorComponent as ErrorComponent } from '@ngx-validate/core';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "@abp/ng.core";
export class ValidationErrorComponent extends ErrorComponent {
    get abpErrors() {
        if (!this.errors || !this.errors.length)
            return [];
        return this.errors.map((error) => {
            if (!error.message)
                return { ...error, interpoliteParams: [] };
            const index = error.message.indexOf('[');
            if (index > -1) {
                return {
                    ...error,
                    message: error.message.slice(0, index),
                    interpoliteParams: error.message
                        .slice(index + 1, error.message.length - 1)
                        .split(','),
                };
            }
            return { ...error, interpoliteParams: [] };
        });
    }
}
ValidationErrorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.0", ngImport: i0, type: ValidationErrorComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
ValidationErrorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.0", type: ValidationErrorComponent, selector: "abp-validation-error", usesInheritance: true, ngImport: i0, template: `
    <div
      class="invalid-feedback"
      *ngFor="let error of abpErrors; trackBy: trackByFn"
    >
      {{ error.message | abpLocalization: error.interpoliteParams }}
    </div>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "pipe", type: i2.LocalizationPipe, name: "abpLocalization" }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.0", ngImport: i0, type: ValidationErrorComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'abp-validation-error',
                    template: `
    <div
      class="invalid-feedback"
      *ngFor="let error of abpErrors; trackBy: trackByFn"
    >
      {{ error.message | abpLocalization: error.interpoliteParams }}
    </div>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGlvbi1lcnJvci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9saWJzL2FicC1sZXB0b24teC9zcmMvbGliL2NvbXBvbmVudHMvdmFsaWRhdGlvbi1lcnJvci92YWxpZGF0aW9uLWVycm9yLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3RGLE9BQU8sRUFBYyx3QkFBd0IsSUFBSSxjQUFjLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQzs7OztBQWU1RixNQUFNLE9BQU8sd0JBQXlCLFNBQVEsY0FBYztJQUMxRCxJQUFJLFNBQVM7UUFDWCxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTTtZQUFFLE9BQU8sRUFBRSxDQUFDO1FBRW5ELE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUMvQixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU87Z0JBQUUsT0FBTyxFQUFFLEdBQUcsS0FBSyxFQUFFLGlCQUFpQixFQUFFLEVBQUUsRUFBRSxDQUFDO1lBRS9ELE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBRXpDLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQyxFQUFFO2dCQUNkLE9BQU87b0JBQ0wsR0FBRyxLQUFLO29CQUNSLE9BQU8sRUFBRSxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDO29CQUN0QyxpQkFBaUIsRUFBRSxLQUFLLENBQUMsT0FBTzt5QkFDN0IsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLEVBQUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO3lCQUMxQyxLQUFLLENBQUMsR0FBRyxDQUFDO2lCQUNkLENBQUM7YUFDSDtZQUVELE9BQU8sRUFBRSxHQUFHLEtBQUssRUFBRSxpQkFBaUIsRUFBRSxFQUFFLEVBQUUsQ0FBQztRQUM3QyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7O3FIQXJCVSx3QkFBd0I7eUdBQXhCLHdCQUF3QixtRkFYekI7Ozs7Ozs7R0FPVDsyRkFJVSx3QkFBd0I7a0JBYnBDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLHNCQUFzQjtvQkFDaEMsUUFBUSxFQUFFOzs7Ozs7O0dBT1Q7b0JBQ0QsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07b0JBQy9DLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO2lCQUN0QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFZhbGlkYXRpb24sIFZhbGlkYXRpb25FcnJvckNvbXBvbmVudCBhcyBFcnJvckNvbXBvbmVudCB9IGZyb20gJ0BuZ3gtdmFsaWRhdGUvY29yZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ2FicC12YWxpZGF0aW9uLWVycm9yJyxcclxuICB0ZW1wbGF0ZTogYFxyXG4gICAgPGRpdlxyXG4gICAgICBjbGFzcz1cImludmFsaWQtZmVlZGJhY2tcIlxyXG4gICAgICAqbmdGb3I9XCJsZXQgZXJyb3Igb2YgYWJwRXJyb3JzOyB0cmFja0J5OiB0cmFja0J5Rm5cIlxyXG4gICAgPlxyXG4gICAgICB7eyBlcnJvci5tZXNzYWdlIHwgYWJwTG9jYWxpemF0aW9uOiBlcnJvci5pbnRlcnBvbGl0ZVBhcmFtcyB9fVxyXG4gICAgPC9kaXY+XHJcbiAgYCxcclxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgVmFsaWRhdGlvbkVycm9yQ29tcG9uZW50IGV4dGVuZHMgRXJyb3JDb21wb25lbnQge1xyXG4gIGdldCBhYnBFcnJvcnMoKTogQXJyYXk8VmFsaWRhdGlvbi5FcnJvciAmIHsgaW50ZXJwb2xpdGVQYXJhbXM6IHN0cmluZ1tdIH0+IHtcclxuICAgIGlmICghdGhpcy5lcnJvcnMgfHwgIXRoaXMuZXJyb3JzLmxlbmd0aCkgcmV0dXJuIFtdO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmVycm9ycy5tYXAoKGVycm9yKSA9PiB7XHJcbiAgICAgIGlmICghZXJyb3IubWVzc2FnZSkgcmV0dXJuIHsgLi4uZXJyb3IsIGludGVycG9saXRlUGFyYW1zOiBbXSB9O1xyXG5cclxuICAgICAgY29uc3QgaW5kZXggPSBlcnJvci5tZXNzYWdlLmluZGV4T2YoJ1snKTtcclxuXHJcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIC4uLmVycm9yLFxyXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZS5zbGljZSgwLCBpbmRleCksXHJcbiAgICAgICAgICBpbnRlcnBvbGl0ZVBhcmFtczogZXJyb3IubWVzc2FnZVxyXG4gICAgICAgICAgICAuc2xpY2UoaW5kZXggKyAxLCBlcnJvci5tZXNzYWdlLmxlbmd0aCAtIDEpXHJcbiAgICAgICAgICAgIC5zcGxpdCgnLCcpLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7IC4uLmVycm9yLCBpbnRlcnBvbGl0ZVBhcmFtczogW10gfTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG4iXX0=