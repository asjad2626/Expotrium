import * as i0 from '@angular/core';
import { InjectionToken, ElementRef, Directive, Input, Component, ChangeDetectionStrategy, ViewEncapsulation, ContentChild, Optional, Self, SkipSelf, TemplateRef, ComponentRef, NgModule } from '@angular/core';
import { Subject, merge, NEVER, ReplaySubject, Subscription } from 'rxjs';
import { takeUntil, mapTo, filter, tap, map } from 'rxjs/operators';
import * as i1 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i1$1 from '@angular/forms';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';

const BLUEPRINTS = {
    email: 'Please enter a valid email address.',
    max: 'Max. value should be {{ max }}. ({{ actual }} entered)',
    maxlength: 'Max. {{ requiredLength }} characters are allowed. (has {{ actualLength }})',
    min: 'Min. value should be {{ min }}. ({{ actual }} entered)',
    minlength: 'Min. {{ requiredLength }} characters are required. (has {{ actualLength }})',
    pattern: 'Invalid pattern. Please review your input.',
    required: 'This field is required.',
    passwordMismatch: 'Passwords do not match.',
    invalidPassword: 'Password should include {{ description }}.',
};

const VALIDATION_BLUEPRINTS = new InjectionToken('validation.blueprints');

const VALIDATION_ERROR_TEMPLATE = new InjectionToken('validation.error.template');

const VALIDATION_INVALID_CLASSES = new InjectionToken('validation.invalid.classes');

const VALIDATION_MAP_ERRORS_FN = new InjectionToken('validation.map.errors.fn');

const VALIDATION_TARGET_SELECTOR = new InjectionToken('validation.target.selector');

const VALIDATION_VALIDATE_ON_SUBMIT = new InjectionToken('validation.validate.on.submit');

function evalPropTruthy(prop) {
    return prop || typeof prop === 'string';
}

const CHARMAP = {
    á: 'a',
    Á: 'A',
    À: 'A',
    à: 'a',
    Ă: 'A',
    ă: 'a',
    Ắ: 'A',
    ắ: 'a',
    ằ: 'a',
    Ằ: 'A',
    Ẵ: 'A',
    ẵ: 'a',
    ẳ: 'a',
    Ẳ: 'A',
    â: 'a',
    Â: 'A',
    ấ: 'a',
    Ấ: 'A',
    ầ: 'a',
    Ầ: 'A',
    ǎ: 'a',
    Ǎ: 'A',
    å: 'a',
    Å: 'A',
    Ǻ: 'A',
    ǻ: 'a',
    ä: 'a',
    Ä: 'A',
    a̋: 'a',
    A̋: 'A',
    Ã: 'A',
    ã: 'a',
    A̧: 'A',
    a̧: 'a',
    Ą: 'A',
    ą: 'a',
    ā: 'a',
    Ā: 'A',
    ȁ: 'a',
    Ȁ: 'A',
    ȃ: 'a',
    Ȃ: 'A',
    Ặ: 'A',
    ặ: 'a',
    æ: 'a',
    Æ: 'A',
    Ǽ: 'A',
    ǽ: 'a',
    b̌: 'b',
    B̌: 'B',
    b̧: 'b',
    B̧: 'B',
    ć: 'c',
    Ć: 'C',
    c̆: 'c',
    C̆: 'C',
    ĉ: 'c',
    Ĉ: 'C',
    č: 'c',
    Č: 'C',
    ċ: 'c',
    Ċ: 'C',
    Ç: 'C',
    ç: 'c',
    Ḉ: 'C',
    ḉ: 'c',
    č̣: 'c',
    Č̣: 'C',
    Ď: 'D',
    ď: 'd',
    ḑ: 'd',
    Ḑ: 'D',
    đ: 'd',
    Đ: 'D',
    Ð: 'D',
    ð: 'd',
    É: 'E',
    é: 'e',
    È: 'E',
    è: 'e',
    Ĕ: 'E',
    ĕ: 'e',
    ê: 'e',
    Ê: 'E',
    Ế: 'E',
    ế: 'e',
    ề: 'e',
    Ề: 'E',
    Ê̌: 'E',
    ê̌: 'e',
    Ě: 'E',
    ě: 'e',
    ë: 'e',
    Ë: 'E',
    e̋: 'e',
    E̋: 'E',
    Ė: 'E',
    ė: 'e',
    Ȩ: 'E',
    ȩ: 'e',
    ḝ: 'e',
    Ḝ: 'E',
    Ę: 'E',
    ę: 'e',
    Ē: 'E',
    ē: 'e',
    Ḗ: 'E',
    ḗ: 'e',
    Ḕ: 'E',
    ḕ: 'e',
    Ȅ: 'E',
    ȅ: 'e',
    Ȇ: 'E',
    ȇ: 'e',
    ɛ̧: 'e',
    Ɛ̧: 'E',
    f̌: 'f',
    F̌: 'F',
    ƒ: 'f',
    ǵ: 'g',
    Ǵ: 'G',
    ğ: 'g',
    Ğ: 'G',
    Ĝ: 'G',
    ĝ: 'g',
    ǧ: 'g',
    Ǧ: 'G',
    Ġ: 'G',
    ġ: 'g',
    ģ: 'g',
    Ģ: 'G',
    Ĥ: 'H',
    ĥ: 'h',
    ȟ: 'h',
    Ȟ: 'H',
    ḩ: 'h',
    Ḩ: 'H',
    ħ: 'h',
    Ħ: 'H',
    ḫ: 'h',
    Ḫ: 'H',
    í: 'i',
    Í: 'I',
    Ì: 'I',
    ì: 'i',
    Ĭ: 'I',
    ĭ: 'i',
    Î: 'I',
    î: 'i',
    ǐ: 'i',
    Ǐ: 'I',
    ï: 'i',
    Ï: 'I',
    ḯ: 'i',
    Ḯ: 'I',
    I̋: 'I',
    i̋: 'i',
    ĩ: 'i',
    Ĩ: 'I',
    İ: 'I',
    I̧: 'I',
    i̧: 'i',
    Į: 'I',
    į: 'i',
    ī: 'i',
    Ī: 'I',
    ȉ: 'i',
    Ȉ: 'I',
    ȋ: 'i',
    Ȋ: 'I',
    ĳ: 'i',
    Ĳ: 'I',
    ı: 'i',
    Ɨ̧: 'I',
    ɨ̧: 'i',
    ĵ: 'j',
    Ĵ: 'J',
    ǰ: 'j',
    J̌: 'J',
    Ḱ: 'K',
    ḱ: 'k',
    k̆: 'k',
    K̆: 'K',
    ǩ: 'k',
    Ǩ: 'K',
    ķ: 'k',
    Ķ: 'K',
    Ĺ: 'L',
    ĺ: 'l',
    Ľ: 'L',
    ľ: 'l',
    ļ: 'l',
    Ļ: 'L',
    ł: 'l',
    Ł: 'l',
    Ŀ: 'L',
    ŀ: 'l',
    Ḿ: 'M',
    ḿ: 'm',
    m̆: 'm',
    M̆: 'M',
    m̌: 'm',
    M̌: 'M',
    M̧: 'M',
    m̧: 'm',
    Ń: 'N',
    ń: 'n',
    Ǹ: 'N',
    ǹ: 'n',
    n̆: 'n',
    N̆: 'N',
    Ň: 'N',
    ň: 'n',
    ñ: 'n',
    Ñ: 'N',
    Ņ: 'N',
    ņ: 'n',
    ó: 'o',
    Ó: 'O',
    Ò: 'O',
    ò: 'o',
    Ŏ: 'O',
    ŏ: 'o',
    Ô: 'O',
    ô: 'o',
    ố: 'o',
    Ố: 'O',
    ồ: 'o',
    Ồ: 'O',
    Ǒ: 'O',
    ǒ: 'o',
    Ö: 'O',
    ö: 'o',
    ő: 'o',
    Ő: 'O',
    Õ: 'O',
    õ: 'o',
    ṍ: 'o',
    Ṍ: 'O',
    Ø: 'O',
    ø: 'o',
    Ǿ: 'O',
    ǿ: 'o',
    o̧: 'o',
    O̧: 'O',
    Ō: 'O',
    ō: 'o',
    ṓ: 'o',
    Ṓ: 'O',
    ṑ: 'o',
    Ṑ: 'O',
    ȍ: 'o',
    Ȍ: 'O',
    ȏ: 'o',
    Ȏ: 'O',
    ơ: 'o',
    Ơ: 'O',
    œ: 'o',
    Œ: 'O',
    ṕ: 'p',
    Ṕ: 'P',
    p̆: 'p',
    P̆: 'P',
    P̌: 'P',
    p̌: 'p',
    Q̌: 'Q',
    q̌: 'q',
    Q̧: 'Q',
    q̧: 'q',
    ŕ: 'r',
    Ŕ: 'R',
    r̆: 'r',
    R̆: 'R',
    Ř: 'R',
    ř: 'r',
    ŗ: 'r',
    Ŗ: 'R',
    Ř̩: 'R',
    ř̩: 'r',
    ȑ: 'r',
    Ȑ: 'R',
    Ȓ: 'R',
    ȓ: 'r',
    Ś: 'S',
    ś: 's',
    Ṥ: 'S',
    ṥ: 's',
    Ŝ: 'S',
    ŝ: 's',
    š: 's',
    Š: 'S',
    Ṧ: 'S',
    ṧ: 's',
    ş: 's',
    Ş: 'S',
    ș: 's',
    Ș: 'S',
    ſ: 's',
    T̆: 'T',
    t̆: 't',
    Ť: 'T',
    ť: 't',
    ţ: 't',
    Ţ: 'T',
    Ț: 'T',
    ț: 't',
    ŧ: 't',
    Ŧ: 'T',
    Ú: 'U',
    ú: 'u',
    ù: 'u',
    Ù: 'U',
    ŭ: 'u',
    Ŭ: 'U',
    Û: 'U',
    û: 'u',
    ǔ: 'u',
    Ǔ: 'U',
    Ů: 'U',
    ů: 'u',
    ü: 'u',
    Ü: 'U',
    ǘ: 'u',
    Ǘ: 'U',
    Ǜ: 'U',
    ǜ: 'u',
    ǚ: 'u',
    Ǚ: 'U',
    ǖ: 'u',
    Ǖ: 'U',
    Ű: 'U',
    ű: 'u',
    ũ: 'u',
    Ũ: 'U',
    Ṹ: 'U',
    ṹ: 'u',
    u̧: 'u',
    U̧: 'U',
    Ų: 'U',
    ų: 'u',
    Ū: 'U',
    ū: 'u',
    ȕ: 'u',
    Ȕ: 'U',
    Ȗ: 'U',
    ȗ: 'u',
    ư: 'u',
    Ư: 'U',
    ứ: 'u',
    Ứ: 'U',
    ừ: 'u',
    Ừ: 'U',
    V̆: 'V',
    v̆: 'v',
    v̌: 'v',
    V̌: 'V',
    Ẃ: 'W',
    ẃ: 'w',
    Ẁ: 'W',
    ẁ: 'w',
    ŵ: 'w',
    Ŵ: 'W',
    W̌: 'W',
    w̌: 'w',
    x́: 'x',
    X́: 'X',
    X̆: 'X',
    x̆: 'x',
    x̌: 'x',
    X̌: 'X',
    X̧: 'X',
    x̧: 'x',
    Ý: 'Y',
    ý: 'y',
    Ỳ: 'Y',
    ỳ: 'y',
    y̆: 'y',
    Y̆: 'Y',
    Ŷ: 'Y',
    ŷ: 'y',
    y̌: 'y',
    Y̌: 'Y',
    ÿ: 'y',
    Ÿ: 'Y',
    ź: 'z',
    Ź: 'Z',
    Ž: 'Z',
    ž: 'z',
    Ż: 'Z',
    ż: 'z',
    Z̧: 'Z',
    z̧: 'z',
};
function interpolate(text) {
    return '{{\\s*(' + text + ')\\s*}}';
}
function mapReplace(blueprint, map, interpolation) {
    if (typeof blueprint !== 'string')
        return '';
    if (typeof map !== 'object')
        return blueprint;
    const expression = Object.keys(map).join('|');
    const mapRegExp = new RegExp(interpolation ? interpolate(expression) : expression, 'g');
    return blueprint.replace(mapRegExp, match => {
        if (interpolation)
            return String(map[match.replace(/\{\{\s*|\s*\}\}/g, '')]);
        return String(map[match]);
    });
}
function normalizeDiacritics(text) {
    return mapReplace(text, CHARMAP);
}
function addCommas(list) {
    return list.reduce((acc, item, index, { length }) => acc +
        (!index
            ? ''
            : length < 3
                ? ' and '
                : index === length - 1
                    ? ', and '
                    : ', ') +
        item, '');
}

function generateValidationError(key, params, blueprint) {
    return {
        key,
        params,
        message: mapReplace(blueprint, params, true),
    };
}
const defaultMapErrorsFn = (errors) => {
    return errors;
};

/**
 * @deprecated doesn't work with Ivy, will be removed in v1.0
 */
function takeUntilDestroy(component) {
    const proto = Object.getPrototypeOf(component);
    const onDestroy = proto.ngOnDestroy;
    const destroy$ = new Subject();
    proto.ngOnDestroy = function () {
        onDestroy.apply(this, arguments);
        destroy$.next();
        destroy$.complete();
    };
    return takeUntil(destroy$);
}

class AbstractValidationDirective {
    constructor(injector) {
        this.injector = injector;
        this.config = {
            blueprints: injector.get(VALIDATION_BLUEPRINTS),
            errorTemplate: injector.get(VALIDATION_ERROR_TEMPLATE),
            invalidClasses: injector.get(VALIDATION_INVALID_CLASSES),
            mapErrorsFn: injector.get(VALIDATION_MAP_ERRORS_FN),
            targetSelector: injector.get(VALIDATION_TARGET_SELECTOR),
            validateOnSubmit: injector.get(VALIDATION_VALIDATE_ON_SUBMIT),
        };
        this.elRef = injector.get(ElementRef);
    }
    get group() {
        return ((this.groupRef || {}).form ||
            (this.groupName || {}).control);
    }
    get parent() {
        return this.parentRef || { getStream: () => null };
    }
    get blueprints() {
        return {
            ...BLUEPRINTS,
            ...(this._blueprints || this.parent.blueprints || this.config.blueprints || {}),
        };
    }
    get errorTemplate() {
        return this._errorTemplate || this.parent.errorTemplate || this.config.errorTemplate;
    }
    get invalidClasses() {
        return this._invalidClasses || this.parent.invalidClasses || this.config.invalidClasses;
    }
    get mapErrorsFn() {
        return this._mapErrorsFn || this.parent.mapErrorsFn || this.config.mapErrorsFn;
    }
    get skipValidation() {
        return (evalPropTruthy(this._skipValidation) ||
            this.parent.skipValidation ||
            this.config.skipValidation);
    }
    get targetSelector() {
        return this._targetSelector || this.parent.targetSelector || this.config.targetSelector;
    }
    get validateOnSubmit() {
        return (evalPropTruthy(this._validateOnSubmit) ||
            this.parent.validateOnSubmit ||
            this.config.validateOnSubmit);
    }
    getStream(streamName) {
        return merge(this[streamName + '$']
            ? this[streamName + '$'].asObservable()
            : NEVER, this.parent.getStream(streamName) || NEVER);
    }
    ngOnDestroy() { }
}
AbstractValidationDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.7", ngImport: i0, type: AbstractValidationDirective, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Directive });
AbstractValidationDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.7", type: AbstractValidationDirective, selector: "abstractValidationDirective", inputs: { _blueprints: ["blueprints", "_blueprints"], _errorTemplate: ["errorTemplate", "_errorTemplate"], _invalidClasses: ["invalidClasses", "_invalidClasses"], _mapErrorsFn: ["mapErrorsFn", "_mapErrorsFn"], _skipValidation: ["skipValidation", "_skipValidation"], _targetSelector: ["targetSelector", "_targetSelector"], _validateOnSubmit: ["validateOnSubmit", "_validateOnSubmit"] }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.7", ngImport: i0, type: AbstractValidationDirective, decorators: [{
            type: Directive,
            args: [{
                    /* tslint:disable-next-line */
                    selector: 'abstractValidationDirective',
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }]; }, propDecorators: { _blueprints: [{
                type: Input,
                args: ['blueprints']
            }], _errorTemplate: [{
                type: Input,
                args: ['errorTemplate']
            }], _invalidClasses: [{
                type: Input,
                args: ['invalidClasses']
            }], _mapErrorsFn: [{
                type: Input,
                args: ['mapErrorsFn']
            }], _skipValidation: [{
                type: Input,
                args: ['skipValidation']
            }], _targetSelector: [{
                type: Input,
                args: ['targetSelector']
            }], _validateOnSubmit: [{
                type: Input,
                args: ['validateOnSubmit']
            }] } });

class ValidationErrorComponent {
    constructor() {
        this.trackByFn = (_, item) => item.key;
    }
    get errors() {
        return this.validationErrors || [];
    }
}
ValidationErrorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.7", ngImport: i0, type: ValidationErrorComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ValidationErrorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.2.7", type: ValidationErrorComponent, selector: "validation-error", ngImport: i0, template: `
    <div *ngFor="let error of errors; trackBy: trackByFn" class="invalid-feedback">{{ error.message }}</div>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.7", ngImport: i0, type: ValidationErrorComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'validation-error',
                    template: `
    <div *ngFor="let error of errors; trackBy: trackByFn" class="invalid-feedback">{{ error.message }}</div>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                }]
        }] });

class ValidationTargetDirective {
    constructor(vcRef) {
        this.vcRef = vcRef;
    }
}
ValidationTargetDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.7", ngImport: i0, type: ValidationTargetDirective, deps: [{ token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Directive });
ValidationTargetDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.7", type: ValidationTargetDirective, selector: "[validationTarget]", exportAs: ["validationTarget"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.7", ngImport: i0, type: ValidationTargetDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[validationTarget]',
                    exportAs: 'validationTarget',
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }]; } });

class ValidationContainerDirective {
}
ValidationContainerDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.7", ngImport: i0, type: ValidationContainerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
ValidationContainerDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.7", type: ValidationContainerDirective, selector: "[validationContainer]", queries: [{ propertyName: "targetRef", first: true, predicate: ValidationTargetDirective, descendants: true }], exportAs: ["validationContainer"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.7", ngImport: i0, type: ValidationContainerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[validationContainer]',
                    exportAs: 'validationContainer',
                }]
        }], propDecorators: { targetRef: [{
                type: ContentChild,
                args: [ValidationTargetDirective]
            }] } });

class ValidationGroupDirective extends AbstractValidationDirective {
    constructor(injector, cdRef, groupName, groupRef, parentRef) {
        super(injector);
        this.injector = injector;
        this.cdRef = cdRef;
        this.groupName = groupName;
        this.groupRef = groupRef;
        this.parentRef = parentRef;
        this.status$ = new ReplaySubject(1);
        this.submit$ = new ReplaySubject(1);
        this.value$ = new ReplaySubject(1);
        this.subs = new Subscription();
    }
    subscribeToFormSubmit() {
        this.elRef.nativeElement.onsubmit = event => {
            if (this.group.invalid)
                event.preventDefault();
            this.submit$.next(this.group);
            this.cdRef.markForCheck();
        };
    }
    subscribeToStatusChanges() {
        this.subs.add(this.group.statusChanges.subscribe(() => {
            this.status$.next(this.group);
            this.cdRef.markForCheck();
        }));
    }
    subscribeToValueChanges() {
        this.subs.add(this.group.valueChanges.subscribe(() => {
            this.value$.next(this.group);
            this.cdRef.markForCheck();
        }));
    }
    ngAfterViewInit() {
        if (!this.parentRef)
            this.subscribeToFormSubmit();
        this.subscribeToStatusChanges();
        this.subscribeToValueChanges();
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
}
ValidationGroupDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.7", ngImport: i0, type: ValidationGroupDirective, deps: [{ token: i0.Injector }, { token: i0.ChangeDetectorRef }, { token: i1$1.FormGroupName, optional: true, self: true }, { token: i1$1.FormGroupDirective, optional: true, self: true }, { token: ValidationGroupDirective, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.Directive });
ValidationGroupDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.7", type: ValidationGroupDirective, selector: "[formGroup],[formGroupName]", exportAs: ["validationGroup"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.7", ngImport: i0, type: ValidationGroupDirective, decorators: [{
            type: Directive,
            args: [{
                    /* tslint:disable-next-line */
                    selector: '[formGroup],[formGroupName]',
                    exportAs: 'validationGroup',
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i0.ChangeDetectorRef }, { type: i1$1.FormGroupName, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }] }, { type: i1$1.FormGroupDirective, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }] }, { type: ValidationGroupDirective, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }]; } });

class ValidationStyleDirective {
    constructor(elRef) {
        this.elRef = elRef;
    }
}
ValidationStyleDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.7", ngImport: i0, type: ValidationStyleDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
ValidationStyleDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.7", type: ValidationStyleDirective, selector: "[validationStyle]", exportAs: ["validationStyle"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.7", ngImport: i0, type: ValidationStyleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[validationStyle]',
                    exportAs: 'validationStyle',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });

class ValidationDirective extends AbstractValidationDirective {
    constructor(injector, cdRef, control, renderer, vcRef, parentRef, markRef, targetRef, containerRef, formGroupDirective) {
        super(injector);
        this.injector = injector;
        this.cdRef = cdRef;
        this.control = control;
        this.renderer = renderer;
        this.vcRef = vcRef;
        this.parentRef = parentRef;
        this.markRef = markRef;
        this.targetRef = targetRef;
        this.containerRef = containerRef;
        this.formGroupDirective = formGroupDirective;
        this.isSubmitted = false;
        this.subscriptions = new Subscription();
    }
    get validation$() {
        return merge(this.parent.getStream('status').pipe(mapTo(null)), this.parent.getStream('value').pipe(mapTo(null)), this.parent.getStream('submit'));
    }
    buildErrors(errors) {
        return Object.keys(errors || {}).map(key => generateValidationError(key, errors[key], this.blueprints[key]));
    }
    insertErrorClasses() {
        this.renderer.addClass(this.markElement, this.invalidClasses);
    }
    insertErrors(errors) {
        const template = this.errorTemplate;
        const targetRef = this.containerRef ? this.containerRef.targetRef : this.targetRef;
        const vcRef = targetRef ? targetRef.vcRef : this.vcRef;
        this.errorRef =
            template instanceof TemplateRef
                ? vcRef.createEmbeddedView(template, { $implicit: errors }, vcRef.length)
                : vcRef.createComponent(template, { index: vcRef.length, injector: this.injector });
        if (this.errorRef instanceof ComponentRef && this.errorRef.instance)
            this.errorRef.instance.validationErrors = errors;
    }
    removeErrorClasses() {
        this.renderer.removeClass(this.markElement, this.invalidClasses);
    }
    removeErrors() {
        if (this.errorRef) {
            this.errorRef.destroy();
            this.errorRef = null;
        }
    }
    setMarkElement() {
        this.markElement =
            (this.markRef
                ? this.markRef.elRef.nativeElement
                : this.targetSelector
                    ? this.elRef.nativeElement.closest(this.targetSelector)
                    : null) || this.elRef.nativeElement;
    }
    shouldValidate(errors) {
        return errors.length && this.control.dirty && (!this.validateOnSubmit || this.isSubmitted);
    }
    subscribeToValidation() {
        let cached;
        this.subscriptions.add(this.validation$
            .pipe(filter(() => !this.skipValidation), tap(form => {
            if (form && this.formGroupDirective.submitted) {
                this.control.control.markAsDirty();
                this.isSubmitted = true;
            }
        }), map(() => this.mapErrorsFn(this.buildErrors(this.control.errors), this.buildErrors((this.parentRef.group || {}).errors), this.control)))
            .subscribe(errors => {
            if (cached === JSON.stringify(errors))
                return;
            this.removeErrors();
            if (this.shouldValidate(errors)) {
                this.insertErrors(errors);
                if (!cached)
                    this.insertErrorClasses();
                cached = JSON.stringify(errors);
            }
            else {
                this.removeErrorClasses();
                cached = '';
            }
            this.cdRef.markForCheck();
        }));
    }
    ngAfterViewInit() {
        this.setMarkElement();
        this.subscribeToValidation();
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
}
ValidationDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.7", ngImport: i0, type: ValidationDirective, deps: [{ token: i0.Injector }, { token: i0.ChangeDetectorRef }, { token: i1$1.NgControl, self: true }, { token: i0.Renderer2 }, { token: i0.ViewContainerRef }, { token: ValidationGroupDirective, skipSelf: true }, { token: ValidationStyleDirective, optional: true, skipSelf: true }, { token: ValidationTargetDirective, optional: true, skipSelf: true }, { token: ValidationContainerDirective, optional: true }, { token: i1$1.FormGroupDirective, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
ValidationDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.7", type: ValidationDirective, selector: "[formControl],[formControlName]", exportAs: ["validationDirective"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.7", ngImport: i0, type: ValidationDirective, decorators: [{
            type: Directive,
            args: [{
                    /* tslint:disable-next-line */
                    selector: '[formControl],[formControlName]',
                    exportAs: 'validationDirective',
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i0.ChangeDetectorRef }, { type: i1$1.NgControl, decorators: [{
                    type: Self
                }] }, { type: i0.Renderer2 }, { type: i0.ViewContainerRef }, { type: ValidationGroupDirective, decorators: [{
                    type: SkipSelf
                }] }, { type: ValidationStyleDirective, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }, { type: ValidationTargetDirective, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }, { type: ValidationContainerDirective, decorators: [{
                    type: Optional
                }] }, { type: i1$1.FormGroupDirective, decorators: [{
                    type: Optional
                }] }]; } });

class NgxValidateCoreModule {
    static forRoot(config = {}) {
        return {
            ngModule: NgxValidateCoreModule,
            providers: [
                {
                    provide: VALIDATION_BLUEPRINTS,
                    useValue: config.blueprints || BLUEPRINTS,
                },
                {
                    provide: VALIDATION_ERROR_TEMPLATE,
                    useValue: config.errorTemplate || ValidationErrorComponent,
                },
                {
                    provide: VALIDATION_INVALID_CLASSES,
                    useValue: config.invalidClasses || 'is-invalid',
                },
                {
                    provide: VALIDATION_MAP_ERRORS_FN,
                    useValue: config.mapErrorsFn || defaultMapErrorsFn,
                },
                {
                    provide: VALIDATION_TARGET_SELECTOR,
                    useValue: config.targetSelector,
                },
                {
                    provide: VALIDATION_VALIDATE_ON_SUBMIT,
                    useValue: config.validateOnSubmit,
                },
            ],
        };
    }
}
NgxValidateCoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.7", ngImport: i0, type: NgxValidateCoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgxValidateCoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.7", ngImport: i0, type: NgxValidateCoreModule, declarations: [ValidationErrorComponent,
        AbstractValidationDirective,
        ValidationContainerDirective,
        ValidationGroupDirective,
        ValidationStyleDirective,
        ValidationTargetDirective,
        ValidationDirective], imports: [CommonModule, FormsModule, ReactiveFormsModule], exports: [ValidationContainerDirective,
        ValidationGroupDirective,
        ValidationStyleDirective,
        ValidationTargetDirective,
        ValidationDirective] });
NgxValidateCoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.7", ngImport: i0, type: NgxValidateCoreModule, imports: [CommonModule, FormsModule, ReactiveFormsModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.7", ngImport: i0, type: NgxValidateCoreModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, FormsModule, ReactiveFormsModule],
                    exports: [
                        ValidationContainerDirective,
                        ValidationGroupDirective,
                        ValidationStyleDirective,
                        ValidationTargetDirective,
                        ValidationDirective,
                    ],
                    declarations: [
                        ValidationErrorComponent,
                        AbstractValidationDirective,
                        ValidationContainerDirective,
                        ValidationGroupDirective,
                        ValidationStyleDirective,
                        ValidationTargetDirective,
                        ValidationDirective,
                    ],
                }]
        }] });

function comparePasswords([controlName1, controlName2]) {
    return (group) => {
        const password = group.get(controlName1).value;
        const repeat = group.get(controlName2).value;
        return !password || !repeat || password === repeat
            ? null
            : {
                passwordMismatch: {
                    fields: [controlName1, controlName2],
                },
            };
    };
}
function validatePassword(shouldContain = ['small', 'capital', 'number', 'special']) {
    return (control) => {
        if (!control.value)
            return null;
        const value = normalizeDiacritics(control.value);
        const regex = {
            small: /.*[a-z].*/,
            capital: /.*[A-Z].*/,
            number: /.*[0-9].*/,
            special: /.*[^0-9a-zA-Z].*/,
        };
        const missing = shouldContain.filter(key => !regex[key].test(value));
        return missing.length
            ? {
                invalidPassword: {
                    missing,
                    description: addCommas(missing.map(key => ({
                        small: 'a small letter',
                        capital: 'a capital',
                        number: 'a number',
                        special: 'a special character',
                    }[key]))),
                },
            }
            : null;
    };
}

/*
 * Public API Surface of core
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AbstractValidationDirective, BLUEPRINTS, NgxValidateCoreModule, VALIDATION_BLUEPRINTS, VALIDATION_ERROR_TEMPLATE, VALIDATION_INVALID_CLASSES, VALIDATION_MAP_ERRORS_FN, VALIDATION_TARGET_SELECTOR, VALIDATION_VALIDATE_ON_SUBMIT, ValidationContainerDirective, ValidationDirective, ValidationErrorComponent, ValidationGroupDirective, ValidationStyleDirective, ValidationTargetDirective, addCommas, comparePasswords, defaultMapErrorsFn, evalPropTruthy, generateValidationError, interpolate, mapReplace, normalizeDiacritics, takeUntilDestroy, validatePassword };
//# sourceMappingURL=ngx-validate-core.mjs.map
